# JavaScript Objects and OOP - Complete Guide

## 1. What are Objects and Why?

**Objects** are collections of related data and functionality stored together.

### Why Use Objects?

#### 1. Reduce Repetition (DRY Principle)
```javascript
// Without objects - repetitive
const userName1 = 'Will';
const userScore1 = 3;

const userName2 = 'Tim';
const userScore2 = 5;

// With objects - organized
const user1 = { name: 'Will', score: 3 };
const user2 = { name: 'Tim', score: 5 };
```

#### 2. Structure Similar Code
```javascript
// Related data grouped together
const user = {
    name: 'Will',
    score: 3,
    level: 'beginner'
};

// Easy to understand what belongs together
```

#### 3. Bundle Functions and Data (Encapsulation)
```javascript
// Data and behavior in one place
const user = {
    name: 'Will',
    score: 3,
    increment: function() {
        this.score++;
    }
};

// Everything about 'user' is together
```

**Encapsulation** means bundling data and methods that operate on that data within a single unit (object).

---

## 2. Object with Method - Memory Context

```javascript
const user1 = {
    name: 'Will',
    score: 3,
    increment: function() { user1.score++; }
};

user1.increment();
```

### Execution Context - Step by Step

#### Step 1: Create Object
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║                                        ║
║  user1: ┌──────────────────────────┐  ║
║         │ name: 'Will'             │  ║
║         │ score: 3                 │  ║
║         │ increment: f{}           │  ║
║         │   (function definition)  │  ║
║         └──────────────────────────┘  ║
║                                        ║
╚════════════════════════════════════════╝
```

**Memory Address Representation:**
```
HEAP MEMORY:
┌─────────────────────────────────────┐
│ Address: 0x001                      │
├─────────────────────────────────────┤
│ name: 'Will'                        │
│ score: 3                            │
│ increment: → 0x002 (function ref)   │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ Address: 0x002 (Function)           │
├─────────────────────────────────────┤
│ function() { user1.score++; }       │
└─────────────────────────────────────┘

GLOBAL MEMORY:
user1 → 0x001
```

#### Step 2: Call `user1.increment()`
```
CALL STACK:
┌─────────────────────┐
│ user1.increment()   │ ← EXECUTING
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT       ║
        ║  user1.increment()             ║
        ╠════════════════════════════════╣
        ║  Variable Environment (empty)  ║
        ║                                ║
        ║  Executes: user1.score++       ║
        ║                                ║
        ╚════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 4  ← MODIFIED              ║
║      increment: f{}                    ║
║  }                                     ║
╚════════════════════════════════════════╝
```

**Key Points:**
- Object stored in global memory
- Properties accessible via dot notation
- Method modifies object's own property

---

## 3. Prototype Chain

**Prototype Chain** is JavaScript's mechanism for object inheritance. Objects can inherit properties and methods from other objects.

### What Problem Does It Solve?

**Problem:** If we create 1000 user objects, each has its own copy of `increment` function - wasteful!

```javascript
const user1 = { 
    name: 'Will', 
    increment: function() {...} // Copy 1
};
const user2 = { 
    name: 'Tim', 
    increment: function() {...} // Copy 2 (same function!)
};
// ... 1000 users = 1000 copies of same function
```

**Solution:** Store function once, let all objects access it via prototype chain.

### How Prototype Chain Works

```
╔════════════════════════════════════════╗
║  user1 object                          ║
║  { name: 'Will', score: 3 }            ║
╠════════════════════════════════════════╣
║                                        ║
║  [[Prototype]] (hidden link)           ║
║       ↓                                ║
╠════════════════════════════════════════╣
║  userFunctionStore object              ║
║  { increment: f{}, login: f{} }        ║
╠════════════════════════════════════════╣
║                                        ║
║  [[Prototype]] (hidden link)           ║
║       ↓                                ║
╠════════════════════════════════════════╣
║  Object.prototype                      ║
║  { hasOwnProperty: f{}, toString: f{} }║
╠════════════════════════════════════════╣
║                                        ║
║  [[Prototype]] → null                  ║
║                                        ║
╚════════════════════════════════════════╝
```

**Lookup Process:**
1. Look for property on object itself
2. Not found? Look on object's prototype
3. Not found? Look on prototype's prototype
4. Continue until reaching null

---

## 4. Dot Notation

**Dot Notation** is a way to access properties and methods of an object using a dot (`.`).

### Syntax
```javascript
object.property
object.method()
```

### Examples

#### Accessing Properties
```javascript
const user = {
    name: 'Will',
    score: 3
};

console.log(user.name);   // 'Will'
console.log(user.score);  // 3
```

#### Setting Properties
```javascript
user.name = 'Tim';        // Set property
user.age = 25;            // Add new property
```

#### Calling Methods
```javascript
const user = {
    greet: function() {
        console.log('Hello');
    }
};

user.greet();  // Calls the method
```

### Alternative: Bracket Notation
```javascript
user['name']   // Same as user.name
user['score']  // Same as user.score

// Useful for dynamic property names
const prop = 'name';
user[prop]     // Accesses user.name
```

---

## 5. Creating Object with Dot Notation - Memory Context

```javascript
const user2 = {};
user2.name = 'Tim';
user2.score = 5;
user2.increment = function() { user2.score++; };

user2.increment();
```

### Execution Context - Step by Step

#### Step 1: Create Empty Object
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║                                        ║
║  user2: {}  ← Empty object             ║
║                                        ║
╚════════════════════════════════════════╝
```

#### Step 2: Add `name` Property
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  user2: {                              ║
║      name: 'Tim'  ← Added              ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 3: Add `score` Property
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 5  ← Added                 ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 4: Add `increment` Method
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 5                          ║
║      increment: f{}  ← Added           ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 5: Call `user2.increment()`
```
CALL STACK:
┌─────────────────────┐
│ user2.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════╗
        ║  user2.increment()             ║
        ╠════════════════════════════════╣
        ║  Executes: user2.score++       ║
        ╚════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 6  ← MODIFIED              ║
║      increment: f{}                    ║
║  }                                     ║
╚════════════════════════════════════════╝
```

---

## 6. How to Create an Object

### Method 1: Object Literal (with dot notation inside)
```javascript
const user = {
    name: 'Will',
    score: 3
};
```

### Method 2: Empty Object + Dot Notation
```javascript
const user = {};
user.name = 'Will';
user.score = 3;
```

### Method 3: Empty Object + Bracket Notation
```javascript
const user = {};
user['name'] = 'Will';
user['score'] = 3;
```

### Method 4: Object Constructor
```javascript
const user = new Object();
user.name = 'Will';
user.score = 3;
```

### Method 5: Object.create()
```javascript
const userPrototype = {
    greet: function() { console.log('Hello'); }
};

const user = Object.create(userPrototype);
user.name = 'Will';
user.score = 3;
```

### Simple Example - All Methods
```javascript
// Method 1
const user1 = { name: 'Will', age: 30 };

// Method 2
const user2 = {};
user2.name = 'Tim';
user2.age = 25;

// Method 3
const user3 = {};
user3['name'] = 'Sarah';
user3['age'] = 28;

console.log(user1.name); // 'Will'
console.log(user2.name); // 'Tim'
console.log(user3.name); // 'Sarah'
```

---

## 7. Factory Function - Memory Context

```javascript
function userCreator(name, score) {
    const newUser = {};
    newUser.name = name;
    newUser.score = score;
    newUser.increment = function() { newUser.score++; };
    return newUser;
}

const user1 = userCreator('Will', 3);
const user2 = userCreator('Tim', 5);

user2.increment();
```

### Execution Context - Step by Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userCreator: f{}                      ║
║  user1: ???                            ║
║  user2: ???                            ║
╚════════════════════════════════════════╝
```

#### Step 2: Call `userCreator('Will', 3)`
```
CALL STACK:
┌─────────────────────────────────┐
│ userCreator('Will', 3)          │
├─────────────────────────────────┤
│ Global                          │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  userCreator('Will', 3)                ║
        ╠════════════════════════════════════════╣
        ║  name: 'Will'                          ║
        ║  score: 3                              ║
        ║                                        ║
        ║  newUser: {}  ← Created                ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Build Object in Local Memory
```
        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ╠════════════════════════════════════════╣
        ║  name: 'Will'                          ║
        ║  score: 3                              ║
        ║                                        ║
        ║  newUser: {                            ║
        ║      name: 'Will'                      ║
        ║      score: 3                          ║
        ║      increment: f{}                    ║
        ║  }                                     ║
        ║                                        ║
        ║  returns → newUser                     ║
        ╚════════════════════════════════════════╝
```

#### Step 4: Return to Global
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userCreator: f{}                      ║
║                                        ║
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 3                          ║
║      increment: f{}                    ║
║  }                                     ║
║                                        ║
║  user2: ???                            ║
╚════════════════════════════════════════╝
```

#### Step 5: Call `userCreator('Tim', 5)`
```
CALL STACK:
┌─────────────────────────────────┐
│ userCreator('Tim', 5)           │
├─────────────────────────────────┤
│ Global                          │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  userCreator('Tim', 5)                 ║
        ╠════════════════════════════════════════╣
        ║  name: 'Tim'                           ║
        ║  score: 5                              ║
        ║                                        ║
        ║  newUser: {                            ║
        ║      name: 'Tim'                       ║
        ║      score: 5                          ║
        ║      increment: f{}                    ║
        ║  }                                     ║
        ║                                        ║
        ║  returns → newUser                     ║
        ╚════════════════════════════════════════╝
```

#### Step 6: Both Objects in Global Memory
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userCreator: f{}                      ║
║                                        ║
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 3                          ║
║      increment: f{}  ← Copy 1          ║
║  }                                     ║
║                                        ║
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 5                          ║
║      increment: f{}  ← Copy 2          ║
║  }                                     ║
║                                        ║
╚════════════════════════════════════════╝
```

**Problem:** Each object has its own copy of `increment` function - memory inefficient!

#### Step 7: Call `user2.increment()`
```
CALL STACK:
┌─────────────────────┐
│ user2.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════╗
        ║  user2.increment()             ║
        ╠════════════════════════════════╣
        ║  Executes: newUser.score++     ║
        ║  (newUser refers to user2)     ║
        ╚════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 6  ← MODIFIED              ║
║      increment: f{}                    ║
║  }                                     ║
╚════════════════════════════════════════╝
```

---

## 8. What is Object.create()?

**Object.create()** creates a new object with a specified prototype object.

### Syntax
```javascript
Object.create(prototypeObject)
```

### Simple Example

```javascript
// Step 1: Create prototype object
const animalMethods = {
    eat: function() {
        console.log(this.name + ' is eating');
    },
    sleep: function() {
        console.log(this.name + ' is sleeping');
    }
};

// Step 2: Create object with prototype
const dog = Object.create(animalMethods);
dog.name = 'Buddy';
dog.breed = 'Golden Retriever';

// Step 3: Use methods from prototype
dog.eat();    // 'Buddy is eating'
dog.sleep();  // 'Buddy is sleeping'
```

### How It Works

```
╔════════════════════════════════════════╗
║  dog object                            ║
║  { name: 'Buddy', breed: 'Golden' }    ║
╠════════════════════════════════════════╣
║  [[Prototype]] link                    ║
║       ↓                                ║
║  animalMethods                         ║
║  { eat: f{}, sleep: f{} }              ║
╚════════════════════════════════════════╝
```

**When you call `dog.eat()`:**
1. Look for `eat` on `dog` object - NOT FOUND
2. Look on `dog`'s prototype (`animalMethods`) - FOUND!
3. Execute `eat` function

**Benefit:** Multiple objects can share the same methods without copying them!

```javascript
const cat = Object.create(animalMethods);
cat.name = 'Whiskers';

cat.eat();  // Works! Uses same eat function as dog
```

---

## 9. Object.create with Prototype - Memory Context

```javascript
function userCreator(name, score) {
    const newUser = Object.create(userFunctionStore);
    newUser.name = name;
    newUser.score = score;
    return newUser;
}

const userFunctionStore = {
    increment: function() { this.score++; },
    login: function() { console.log(this.name + ' logged in.'); }
};

const user1 = userCreator('Will', 3);
const user2 = userCreator('Tim', 5);

user2.increment();
user1.hasOwnProperty('name');
```

### Execution Context - Step by Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userCreator: f{}                      ║
║                                        ║
║  userFunctionStore: {                  ║
║      increment: f{}                    ║
║      login: f{}                        ║
║  }                                     ║
║                                        ║
║  user1: ???                            ║
║  user2: ???                            ║
╚════════════════════════════════════════╝
```

#### Step 2: Call `userCreator('Will', 3)`
```
CALL STACK:
┌─────────────────────────────────┐
│ userCreator('Will', 3)          │
├─────────────────────────────────┤
│ Global                          │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ╠════════════════════════════════════════╣
        ║  name: 'Will'                          ║
        ║  score: 3                              ║
        ║                                        ║
        ║  newUser: {}  ← Created with           ║
        ║               Object.create()          ║
        ║                                        ║
        ║  newUser.[[Prototype]] →               ║
        ║      userFunctionStore                 ║
        ╚════════════════════════════════════════╝
```

**Important:** `Object.create(userFunctionStore)` creates empty object with hidden `[[Prototype]]` link to `userFunctionStore`.

#### Step 3: Build Object Properties
```
        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ╠════════════════════════════════════════╣
        ║  newUser: {                            ║
        ║      name: 'Will'                      ║
        ║      score: 3                          ║
        ║      [[Prototype]]: userFunctionStore  ║
        ║  }                                     ║
        ║                                        ║
        ║  returns → newUser                     ║
        ╚════════════════════════════════════════╝
```

#### Step 4: Global Memory After Both Calls
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userFunctionStore: {                  ║
║      increment: f{}  ← Shared          ║
║      login: f{}      ← Shared          ║
║  }                                     ║
║     ↑              ↑                   ║
║     │              │                   ║
║  user1: {          user2: {            ║
║      name: 'Will'      name: 'Tim'     ║
║      score: 3          score: 5        ║
║      [[Prototype]]     [[Prototype]]   ║
║  }                 }                   ║
╚════════════════════════════════════════╝
```

**Visual Prototype Chain:**
```
user1                          user2
  │                              │
  └──[[Prototype]]──┐  ┌─[[Prototype]]
                     ↓  ↓
            userFunctionStore
            { increment: f{}, login: f{} }
                     │
              [[Prototype]]
                     ↓
            Object.prototype
            { hasOwnProperty: f{}, toString: f{} }
                     │
              [[Prototype]]
                     ↓
                   null
```

#### Step 5: Call `user2.increment()`
```
CALL STACK:
┌─────────────────────┐
│ user2.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

Property Lookup:
1. Look for 'increment' on user2 → NOT FOUND
2. Look on user2.[[Prototype]] (userFunctionStore) → FOUND!

        ╔════════════════════════════════════════╗
        ║  increment() from userFunctionStore    ║
        ╠════════════════════════════════════════╣
        ║  this: user2  ← 'this' refers to user2 ║
        ║                                        ║
        ║  Executes: this.score++                ║
        ║  (user2.score++)                       ║
        ╚════════════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user2: {                              ║
║      name: 'Tim'                       ║
║      score: 6  ← MODIFIED              ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 6: Call `user1.hasOwnProperty('name')`
```
Property Lookup:
1. Look for 'hasOwnProperty' on user1 → NOT FOUND
2. Look on userFunctionStore → NOT FOUND
3. Look on Object.prototype → FOUND!

        ╔════════════════════════════════════════╗
        ║  hasOwnProperty('name')                ║
        ║  from Object.prototype                 ║
        ╠════════════════════════════════════════╣
        ║  this: user1                           ║
        ║                                        ║
        ║  Checks if user1 has own property      ║
        ║  'name' (not from prototype)           ║
        ║                                        ║
        ║  Returns: true                         ║
        ╚════════════════════════════════════════╝
```

**Key Benefit:** Both `user1` and `user2` share the same `increment` and `login` functions. No copies!

---

## 10. Object.create() Parameters and __proto__

### Object.create() Parameter

```javascript
Object.create(prototypeObject)
```

**Parameter:** The object that will become the prototype of the newly created object.

**What Happens:**
```javascript
const obj = Object.create(proto);

// Equivalent to:
obj.[[Prototype]] = proto;
```

### What is __proto__?

`__proto__` is a property that provides access to an object's prototype (the `[[Prototype]]` internal property).

**Note:** `[[Prototype]]` is the internal hidden link, `__proto__` is the accessor property to view/modify it.

### Example

```javascript
const parent = {
    greet: function() { console.log('Hello'); }
};

const child = Object.create(parent);

// Access prototype
console.log(child.__proto__ === parent);  // true

// The hidden link
child.[[Prototype]] === parent  // Conceptually true (can't access directly)
child.__proto__ === parent      // true (can access via __proto__)
```

### Visual Representation

```
╔════════════════════════════════════════╗
║  child object                          ║
║  {}                                    ║
╠════════════════════════════════════════╣
║                                        ║
║  __proto__ (accessor property)         ║
║       ↓                                ║
║  [[Prototype]] (internal hidden link)  ║
║       ↓                                ║
║  parent object                         ║
║  { greet: f{} }                        ║
║                                        ║
╚════════════════════════════════════════╝
```

### Detailed Example

```javascript
const methods = {
    sayHello: function() { console.log('Hello'); }
};

const obj = Object.create(methods);
obj.name = 'Test';

// Ways to access prototype:
console.log(obj.__proto__);                    // { sayHello: f{} }
console.log(obj.__proto__ === methods);        // true
console.log(Object.getPrototypeOf(obj));       // { sayHello: f{} }
console.log(Object.getPrototypeOf(obj) === methods); // true

// Property lookup
obj.sayHello();  // Works! Found on prototype
```

### Important Notes:

1. `__proto__` is deprecated but still widely used
2. Use `Object.getPrototypeOf(obj)` and `Object.setPrototypeOf(obj, proto)` instead
3. `[[Prototype]]` is the actual internal link (not directly accessible)
4. `__proto__` is just a getter/setter for `[[Prototype]]`

---

## 11. The `this` Keyword

**`this`** is a special keyword that refers to the object that is executing the current function.

### Simple Rules for `this`:

1. **In a method:** `this` refers to the object the method is called on
2. **In a regular function:** `this` refers to global object (or undefined in strict mode)
3. **In an arrow function:** `this` is inherited from surrounding scope
4. **With `new` keyword:** `this` refers to the newly created object

### Simple Example

```javascript
const user = {
    name: 'Will',
    score: 3,
    increment: function() {
        this.score++;  // 'this' refers to 'user'
    },
    display: function() {
        console.log('Name: ' + this.name);  // 'this' refers to 'user'
    }
};

user.increment();  // this = user, so user.score++
user.display();    // Output: 'Name: Will'
```

### Detailed Example

```javascript
const person1 = {
    name: 'Alice',
    greet: function() {
        console.log('Hi, I am ' + this.name);
    }
};

const person2 = {
    name: 'Bob',
    greet: function() {
        console.log('Hi, I am ' + this.name);
    }
};

person1.greet();  // 'Hi, I am Alice' (this = person1)
person2.greet();  // 'Hi, I am Bob' (this = person2)
```

### How `this` is Determined

```
╔════════════════════════════════════════╗
║  RULE: Look at HOW function is called  ║
╠════════════════════════════════════════╣
║                                        ║
║  obj.method()                          ║
║     ↑                                  ║
║  'this' = obj (object before the dot)  ║
║                                        ║
╚════════════════════════════════════════╝
```

### Example with Prototype Chain

```javascript
const methods = {
    increment: function() {
        this.score++;  // 'this' = object that called increment
    }
};

const user1 = Object.create(methods);
user1.name = 'Will';
user1.score = 3;

const user2 = Object.create(methods);
user2.name = 'Tim';
user2.score = 5;

user1.increment();  // 'this' = user1, so user1.score++
user2.increment();  // 'this' = user2, so user2.score++

console.log(user1.score);  // 4
console.log(user2.score);  // 6
```

**Key Point:** Even though `increment` is stored on `methods`, when called via `user1.increment()`, `this` refers to `user1`.

---

## 12. Where Does `hasOwnProperty` Come From?

`hasOwnProperty` comes from **Object.prototype**, the top of the prototype chain.

### Prototype Chain Journey

```
user1
  │
  └─ [[Prototype]] → userFunctionStore
                       │
                       └─ [[Prototype]] → Object.prototype
                                            │
                                            └─ hasOwnProperty: f{}
                                            └─ toString: f{}
                                            └─ valueOf: f{}
                                            └─ ...
```

### Step-by-Step Lookup for `user1.hasOwnProperty('name')`

```
╔════════════════════════════════════════╗
║  PROPERTY LOOKUP PROCESS               ║
╠════════════════════════════════════════╣
║                                        ║
║  1. Look on user1 object               ║
║     { name: 'Will', score: 3 }         ║
║     hasOwnProperty? NO                 ║
║                                        ║
║  2. Look on user1.[[Prototype]]        ║
║     (userFunctionStore)                ║
║     { increment: f{}, login: f{} }     ║
║     hasOwnProperty? NO                 ║
║                                        ║
║  3. Look on userFunctionStore.[[Proto]]║
║     (Object.prototype)                 ║
║     { hasOwnProperty: f{}, ... }       ║
║     hasOwnProperty? YES! FOUND         ║
║                                        ║
║  4. Execute hasOwnProperty with        ║
║     this = user1                       ║
║                                        ║
╚════════════════════════════════════════╝
```

### Visual Representation

```
user1.hasOwnProperty('name')
  │
  ├─ Step 1: Check user1
  │           { name: 'Will', score: 3 }
  │           Not found ✗
  │
  ├─ Step 2: Check user1.__proto__ (userFunctionStore)
  │           { increment: f{}, login: f{} }
  │           Not found ✗
  │
  └─ Step 3: Check userFunctionStore.__proto__ (Object.prototype)
              { hasOwnProperty: f{}, toString: f{}, ... }
              Found ✓
              Execute with this = user1
              Returns: true
```

### All Objects Inherit from Object.prototype

```javascript
const obj = {};

// These all come from Object.prototype
obj.hasOwnProperty('key');
obj.toString();
obj.valueOf();
obj.constructor;

// They're not on obj itself
console.log(obj.hasOwnProperty('hasOwnProperty')); // false
console.log(Object.prototype.hasOwnProperty('hasOwnProperty')); // true
```

### Object.prototype is the Root

```
╔════════════════════════════════════════╗
║  Every Object's Prototype Chain        ║
╠════════════════════════════════════════╣
║                                        ║
║  Your Object                           ║
║       ↓ [[Prototype]]                  ║
║  Custom Prototype (optional)           ║
║       ↓ [[Prototype]]                  ║
║  Object.prototype                      ║
║  { hasOwnProperty, toString, ... }     ║
║       ↓ [[Prototype]]                  ║
║  null (end of chain)                   ║
║                                        ║
╚════════════════════════════════════════╝
```

---

## 13. `this` Keyword with Arrow Functions

### How Arrow Functions Handle `this`

**Arrow functions do NOT have their own `this`. They inherit `this` from the surrounding scope (lexical `this`).**

### Example with Arrow Function Problem

```javascript
function userCreator(name, score) {
    const newUser = Object.create(userFunctionStore);
    newUser.name = name;
    newUser.score = score;
    return newUser;
}

const userFunctionStore = {
    increment: function() {
        const add1 = () => { 
            this.score++; 
        };
        add1();
    }
};

const user1 = userCreator('Will', 3);
const user2 = userCreator('Tim', 5);

user1.increment();
```

### Execution Context - Step by Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  userCreator: f{}                      ║
║                                        ║
║  userFunctionStore: {                  ║
║      increment: f{}                    ║
║  }                                     ║
║                                        ║
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 3                          ║
║      [[Prototype]]: userFunctionStore  ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 2: Call `user1.increment()`
```
CALL STACK:
┌─────────────────────┐
│ user1.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════════════╗
        ║  increment() EXECUTION CONTEXT         ║
        ╠════════════════════════════════════════╣
        ║  this: user1  ← Set when called        ║
        ║                                        ║
        ║  add1: () => { this.score++; }         ║
        ║         ↑                              ║
        ║  Arrow function defined here           ║
        ║  Captures 'this' from increment        ║
        ║                                        ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Call `add1()`
```
CALL STACK:
┌─────────────────────┐
│ add1()              │ ← Arrow function
├─────────────────────┤
│ user1.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════════════╗
        ║  add1() EXECUTION CONTEXT              ║
        ╠════════════════════════════════════════╣
        ║  NO 'this' binding!                    ║
        ║                                        ║
        ║  Uses 'this' from parent scope         ║
        ║  (increment function)                  ║
        ║                                        ║
        ║  this: user1  ← Inherited              ║
        ║                                        ║
        ║  Executes: this.score++                ║
        ║  (user1.score++)                       ║
        ╚════════════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 4  ← MODIFIED              ║
║  }                                     ║
╚════════════════════════════════════════╝
```

### Why Arrow Function Works Here

```
╔════════════════════════════════════════╗
║  LEXICAL 'this' IN ARROW FUNCTIONS     ║
╠════════════════════════════════════════╣
║                                        ║
║  increment: function() {               ║
║      this = user1  ← Set here          ║
║                                        ║
║      const add1 = () => {              ║
║          this = ???                    ║
║          ↑                             ║
║          Arrow function has NO 'this'  ║
║          Looks in parent scope         ║
║          Finds 'this' from increment   ║
║          this = user1                  ║
║      };                                ║
║  }                                     ║
║                                        ║
╚════════════════════════════════════════╝
```

### What if increment Was Arrow Function?

```javascript
const userFunctionStore = {
    increment: () => {  // Arrow function as method - BAD!
        this.score++;
    }
};

const user1 = Object.create(userFunctionStore);
user1.name = 'Will';
user1.score = 3;

user1.increment();  // ERROR or unexpected behavior
```

**Problem:**
```
╔════════════════════════════════════════╗
║  increment: () => {                    ║
║      this = ???                        ║
║      ↑                                 ║
║      Arrow function looks for 'this'   ║
║      in parent scope (global)          ║
║      this = window (or undefined)      ║
║      NOT user1!                        ║
║  }                                     ║
╚════════════════════════════════════════╝
```

### Key Differences

```
╔════════════════════════════════════════════════════╗
║  Regular Function vs Arrow Function 'this'         ║
╠════════════════════════════════════════════════════╣
║                                                    ║
║  REGULAR FUNCTION:                                 ║
║  function() {                                      ║
║      this = object that called the function        ║
║  }                                                 ║
║                                                    ║
║  ARROW FUNCTION:                                   ║
║  () => {                                           ║
║      this = this from surrounding scope            ║
║  }                                                 ║
║                                                    ║
╚════════════════════════════════════════════════════╝
```

**Rule:** Use regular functions for methods, use arrow functions inside methods when you need to preserve `this`.

---

## 14. Using the `new` Keyword

### Example with `new` Keyword

```javascript
function UserCreator(name, score) {
    this.name = name;
    this.score = score;
}

UserCreator.prototype.increment = function() {
    this.score++;
};

UserCreator.prototype.login = function() {
    console.log(this.name + ' logged in.');
};

const user1 = new UserCreator('Will', 3);
const user2 = new UserCreator('Tim', 5);

user1.increment();
user1.hasOwnProperty('name');
```

### What `new` Keyword Does

When you use `new`, JavaScript automatically:

1. Creates a new empty object
2. Sets the object's `[[Prototype]]` to `Constructor.prototype`
3. Binds `this` to the new object
4. Returns the object (unless function explicitly returns something else)

```
╔════════════════════════════════════════╗
║  new UserCreator('Will', 3)            ║
╠════════════════════════════════════════╣
║                                        ║
║  1. const this = {}                    ║
║                                        ║
║  2. this.[[Prototype]] =               ║
║        UserCreator.prototype           ║
║                                        ║
║  3. UserCreator.call(this, 'Will', 3)  ║
║     (run function with this binding)   ║
║                                        ║
║  4. return this                        ║
║                                        ║
╚════════════════════════════════════════╝
```

### Execution Context - Step by Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  UserCreator: f{}                      ║
║       ↓                                ║
║  UserCreator.prototype: {              ║
║      increment: f{}                    ║
║      login: f{}                        ║
║      constructor: UserCreator          ║
║  }                                     ║
║                                        ║
║  user1: ???                            ║
║  user2: ???                            ║
╚════════════════════════════════════════╝
```

**Important:** Every function has a `prototype` property automatically created.

#### Step 2: Execute `new UserCreator('Will', 3)`
```
CALL STACK:
┌─────────────────────────────────┐
│ UserCreator('Will', 3)          │
├─────────────────────────────────┤
│ Global                          │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  UserCreator EXECUTION CONTEXT         ║
        ╠════════════════════════════════════════╣
        ║  this: {}  ← Auto-created by 'new'     ║
        ║                                        ║
        ║  this.[[Prototype]] =                  ║
        ║      UserCreator.prototype             ║
        ║                                        ║
        ║  name: 'Will' (parameter)              ║
        ║  score: 3 (parameter)                  ║
        ║                                        ║
        ║  Execute: this.name = name             ║
        ║           this.score = score           ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Build Object with `this`
```
        ╔════════════════════════════════════════╗
        ║  this: {                               ║
        ║      name: 'Will'  ← Added             ║
        ║      score: 3      ← Added             ║
        ║      [[Prototype]]:                    ║
        ║          UserCreator.prototype         ║
        ║  }                                     ║
        ║                                        ║
        ║  return this  ← Auto-returned by 'new' ║
        ╚════════════════════════════════════════╝
```

#### Step 4: Global Memory After Both Calls
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  UserCreator.prototype: {              ║
║      increment: f{}  ← Shared          ║
║      login: f{}      ← Shared          ║
║  }                                     ║
║     ↑              ↑                   ║
║     │              │                   ║
║  user1: {          user2: {            ║
║      name: 'Will'      name: 'Tim'     ║
║      score: 3          score: 5        ║
║      [[Prototype]]     [[Prototype]]   ║
║  }                 }                   ║
╚════════════════════════════════════════╝
```

#### Step 5: Call `user1.increment()`
```
Property Lookup:
1. Look on user1 → NOT FOUND
2. Look on user1.[[Prototype]] (UserCreator.prototype) → FOUND!

        ╔════════════════════════════════════════╗
        ║  increment() from                      ║
        ║  UserCreator.prototype                 ║
        ╠════════════════════════════════════════╣
        ║  this: user1                           ║
        ║                                        ║
        ║  Executes: this.score++                ║
        ╚════════════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 4  ← MODIFIED              ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 6: Call `user1.hasOwnProperty('name')`
```
Property Lookup Chain:
1. user1 → NOT FOUND
2. UserCreator.prototype → NOT FOUND
3. Object.prototype → FOUND!

Returns: true
```

### Prototype Chain Visualization

```
user1
  │
  └─ [[Prototype]] → UserCreator.prototype
                       { increment: f{}, login: f{} }
                       │
                       └─ [[Prototype]] → Object.prototype
                                            { hasOwnProperty: f{} }
                                            │
                                            └─ [[Prototype]] → null
```

### Key Points about `new`:

1. **Automates object creation** - No need for `Object.create()`
2. **Auto-returns object** - No explicit `return` needed
3. **Sets prototype automatically** - Links to `Constructor.prototype`
4. **Industry standard** - Most common pattern in JavaScript

---

## 15. ES6 Classes

### Class Syntax

```javascript
class UserCreator {
    constructor(name, score) {
        this.name = name;
        this.score = score;
    }

    increment() {
        this.score++;
    }

    login() {
        console.log(this.name + ' logged in.');
    }
}

const user1 = new UserCreator('Will', 3);
const user2 = new UserCreator('Tim', 5);

user1.increment();
user1.hasOwnProperty('name');
```

### What is a Class?

**Class** is syntactic sugar over JavaScript's prototype-based inheritance. It's a cleaner way to write constructor functions.

```
╔════════════════════════════════════════╗
║  class UserCreator { ... }             ║
║                                        ║
║  Is just a cleaner way to write:       ║
║                                        ║
║  function UserCreator() { ... }        ║
║  UserCreator.prototype.method = ...    ║
║                                        ║
╚════════════════════════════════════════╝
```

### Execution Context - Step by Step

#### Step 1: Class Definition in Global Memory
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  UserCreator: class (actually f{})     ║
║       ↓                                ║
║  UserCreator.prototype: {              ║
║      increment: f{}                    ║
║      login: f{}                        ║
║      constructor: UserCreator          ║
║  }                                     ║
║                                        ║
║  user1: ???                            ║
║  user2: ???                            ║
╚════════════════════════════════════════╝
```

**Behind the Scenes:**
```javascript
// Class syntax
class UserCreator {
    constructor(name, score) {
        this.name = name;
        this.score = score;
    }
    increment() { this.score++; }
}

// Equivalent to:
function UserCreator(name, score) {
    this.name = name;
    this.score = score;
}
UserCreator.prototype.increment = function() {
    this.score++;
};
```

#### Step 2: Call `new UserCreator('Will', 3)`
```
CALL STACK:
┌─────────────────────────────────┐
│ UserCreator('Will', 3)          │
├─────────────────────────────────┤
│ Global                          │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  constructor() EXECUTION CONTEXT       ║
        ╠════════════════════════════════════════╣
        ║  this: {}  ← Auto-created by 'new'     ║
        ║                                        ║
        ║  this.[[Prototype]] =                  ║
        ║      UserCreator.prototype             ║
        ║                                        ║
        ║  name: 'Will'                          ║
        ║  score: 3                              ║
        ║                                        ║
        ║  Execute constructor body:             ║
        ║      this.name = name                  ║
        ║      this.score = score                ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Object Created
```
        ╔════════════════════════════════════════╗
        ║  this: {                               ║
        ║      name: 'Will'                      ║
        ║      score: 3                          ║
        ║      [[Prototype]]:                    ║
        ║          UserCreator.prototype         ║
        ║  }                                     ║
        ║                                        ║
        ║  return this  ← Auto-returned          ║
        ╚════════════════════════════════════════╝
```

#### Step 4: Global Memory After Both Instantiations
```
╔════════════════════════════════════════╗
║     GLOBAL MEMORY                      ║
╠════════════════════════════════════════╣
║  UserCreator.prototype: {              ║
║      increment: f{}  ← Shared          ║
║      login: f{}      ← Shared          ║
║      constructor: UserCreator          ║
║  }                                     ║
║     ↑              ↑                   ║
║     │              │                   ║
║  user1: {          user2: {            ║
║      name: 'Will'      name: 'Tim'     ║
║      score: 3          score: 5        ║
║      [[Prototype]]     [[Prototype]]   ║
║  }                 }                   ║
╚════════════════════════════════════════╝
```

#### Step 5: Call `user1.increment()`
```
Property Lookup:
1. Look on user1 → NOT FOUND
2. Look on UserCreator.prototype → FOUND!

CALL STACK:
┌─────────────────────┐
│ user1.increment()   │
├─────────────────────┤
│ Global              │
└─────────────────────┘

        ╔════════════════════════════════════════╗
        ║  increment() method                    ║
        ╠════════════════════════════════════════╣
        ║  this: user1  ← Set by call site       ║
        ║                                        ║
        ║  Executes: this.score++                ║
        ╚════════════════════════════════════════╝
                ↓
╔════════════════════════════════════════╗
║  user1: {                              ║
║      name: 'Will'                      ║
║      score: 4  ← MODIFIED              ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 6: Call `user1.hasOwnProperty('name')`
```
Property Lookup Chain:
1. user1 → NOT FOUND
2. UserCreator.prototype → NOT FOUND
3. Object.prototype → FOUND!

Returns: true (name is user1's own property)
```

### Class Features

#### 1. Constructor Method
```javascript
class User {
    constructor(name) {  // Called when 'new User()' is used
        this.name = name;
    }
}
```

#### 2. Instance Methods
```javascript
class User {
    greet() {  // Added to User.prototype
        console.log('Hello');
    }
}
```

#### 3. Class Syntax Benefits
```
╔════════════════════════════════════════╗
║  CLASS ADVANTAGES                      ║
╠════════════════════════════════════════╣
║                                        ║
║  1. Cleaner syntax                     ║
║  2. All methods in one place           ║
║  3. Clear structure                    ║
║  4. Industry standard                  ║
║  5. Looks like other languages (OOP)   ║
║                                        ║
╚════════════════════════════════════════╝
```

---

## Complete Comparison: All Patterns

### Pattern 1: Object Literal
```javascript
const user = {
    name: 'Will',
    score: 3,
    increment: function() { this.score++; }
};
```
**Pros:** Simple  
**Cons:** No reusability, method duplication

### Pattern 2: Factory Function
```javascript
function createUser(name, score) {
    return {
        name: name,
        score: score,
        increment: function() { this.score++; }
    };
}
```
**Pros:** Reusable  
**Cons:** Method duplication for each object

### Pattern 3: Factory + Object.create
```javascript
const methods = {
    increment: function() { this.score++; }
};

function createUser(name, score) {
    const user = Object.create(methods);
    user.name = name;
    user.score = score;
    return user;
}
```
**Pros:** Shared methods, efficient  
**Cons:** Manual, verbose

### Pattern 4: Constructor Function with `new`
```javascript
function User(name, score) {
    this.name = name;
    this.score = score;
}

User.prototype.increment = function() {
    this.score++;
};

const user = new User('Will', 3);
```
**Pros:** Industry standard, automated  
**Cons:** Confusing syntax

### Pattern 5: ES6 Class
```javascript
class User {
    constructor(name, score) {
        this.name = name;
        this.score = score;
    }
    
    increment() {
        this.score++;
    }
}

const user = new User('Will', 3);
```
**Pros:** Clean, modern, standard  
**Cons:** Still uses prototypes underneath

---

## Summary

### Key Concepts:

1. **Objects** bundle data and functions together (encapsulation)

2. **Dot Notation** accesses properties: `obj.property`

3. **Prototype Chain** enables inheritance and method sharing

4. **Object.create()** creates objects with specified prototype

5. **__proto__** provides access to an object's prototype

6. **this** keyword refers to the object calling the method

7. **Arrow functions** inherit `this` from surrounding scope

8. **new keyword** automates object creation with prototypes

9. **Classes** are syntactic sugar over constructor functions

10. **hasOwnProperty** comes from Object.prototype via prototype chain

### Prototype Chain Benefits:

- Memory efficiency (shared methods)
- Code reusability
- Inheritance patterns
- Organized code structure

### Best Practices:

- Use ES6 classes for new code (modern, clean)
- Use arrow functions inside methods to preserve `this`
- Don't use arrow functions as methods
- Understand prototypes even when using classes
- Use `hasOwnProperty` to check own properties vs inherited