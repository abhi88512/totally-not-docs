# JavaScript Closures - Complete Guide

## What is a Closure?

**Closure** is when a function "remembers" and has access to variables from its outer (enclosing) function, even after that outer function has finished executing.

**Key Benefit:** Enables powerful patterns like functions that run only once, private variables, and data persistence.

---

## The Problem: No Permanent Memory

### Current Behavior
Every time we run a function, a **brand new local memory** is created from scratch.

```javascript
function multiplyBy2(num) {
    return num * 2;
}

multiplyBy2(7); // Creates local memory, runs, then destroys it
multiplyBy2(7); // Creates NEW local memory again, no memory of previous call
```

**Question:** What if a function could have **permanent memory** attached to it?

**Answer:** That's exactly what **Closures** provide!

---

## Understanding Variable Environment

**Variable Environment** is another name for **Local Memory**.

```
╔════════════════════════════════════════╗
║  EXECUTION CONTEXT                     ║
╠════════════════════════════════════════╣
║  Variable Environment (Local Memory)   ║
║  Thread of Execution                   ║
╚════════════════════════════════════════╝
```

---

## Example 1: Returning a Function

```javascript
function createFunction() {
    function multiplyBy2(num) {
        return num * 2;
    }
    return multiplyBy2;
}

const generatedFunc = createFunction();
const result = generatedFunc(3);
```

### Execution Context Step-by-Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  MEMORY                                ║
║                                        ║
║  createFunction: f{}                   ║
║  generatedFunc: ???                    ║
║  result: ???                           ║
║                                        ║
╚════════════════════════════════════════╝
```

#### Step 2: Call `createFunction()`
```
CALL STACK:
┌─────────────────────────────────┐
│ createFunction()                │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  createFunction()                      ║
        ╠════════════════════════════════════════╣
        ║  Variable Environment (Local Memory)   ║
        ║                                        ║
        ║  multiplyBy2: f{function definition}   ║
        ║                                        ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Return `multiplyBy2`
```
        ╔════════════════════════════════════════╗
        ║  createFunction()                      ║
        ╠════════════════════════════════════════╣
        ║  multiplyBy2: f{}                      ║
        ║                                        ║
        ║  returns → multiplyBy2 definition      ║
        ╚════════════════════════════════════════╝
                    ↓
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  createFunction: f{}                   ║
║  generatedFunc: f{multiplyBy2}         ║
║  result: ???                           ║
║                                        ║
╚════════════════════════════════════════╝
```

**Important:** `generatedFunc` stores the **function definition** of `multiplyBy2`. It has **no direct relationship** with `createFunction()` anymore.

#### Step 4: Call `generatedFunc(3)`
```
CALL STACK:
┌─────────────────────────────────┐
│ generatedFunc(3)                │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  generatedFunc(3)                      ║
        ║  (actually multiplyBy2)                ║
        ╠════════════════════════════════════════╣
        ║  num: 3                                ║
        ║  returns: 6                            ║
        ╚════════════════════════════════════════╝
                    ↓
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  createFunction: f{}                   ║
║  generatedFunc: f{multiplyBy2}         ║
║  result: 6                             ║
╚════════════════════════════════════════╝
```

---

## Example 2: Function Accessing Outer Variable

```javascript
function outer() {
    let counter = 0;
    function incrementCounter() {
        counter++;
    }
    incrementCounter();
}

outer();
```

### Execution Context Step-by-Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  outer: f{}                            ║
╚════════════════════════════════════════╝
```

#### Step 2: Call `outer()`
```
CALL STACK:
┌─────────────────────────────────┐
│ outer()                         │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  outer()                               ║
        ╠════════════════════════════════════════╣
        ║  Variable Environment                  ║
        ║                                        ║
        ║  counter: 0                            ║
        ║  incrementCounter: f{}                 ║
        ║                                        ║
        ╚════════════════════════════════════════╝
```

#### Step 3: Call `incrementCounter()`
```
CALL STACK:
┌─────────────────────────────────┐
│ incrementCounter()              │ ← EXECUTING
├─────────────────────────────────┤
│ outer() (PAUSED)                │
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

                ╔════════════════════════════╗
                ║  incrementCounter()        ║
                ╠════════════════════════════╣
                ║  Variable Environment      ║
                ║  (empty - no local vars)   ║
                ║                            ║
                ║  Accesses counter from     ║
                ║  outer's memory            ║
                ╚════════════════════════════╝
                        ↓
        ╔════════════════════════════════════════╗
        ║  outer()                               ║
        ╠════════════════════════════════════════╣
        ║  counter: 1  ← MODIFIED                ║
        ║  incrementCounter: f{}                 ║
        ╚════════════════════════════════════════╝
```

### Why Does `incrementCounter` Have Access to `counter`?

**Answer:** Because `incrementCounter` is **DEFINED** inside `outer`'s local memory (variable environment).

**Important:** Access is determined by **WHERE the function is DEFINED**, not where it is **RUN**.

This is called **Lexical Scoping** or **Static Scoping**.

---

## Example 3: The Real Closure - Returning Inner Function

```javascript
function outer() {
    let counter = 0;
    function incrementCounter() {
        counter++;
    }
    return incrementCounter;
}

const myNewFunc = outer();
myNewFunc();
myNewFunc();

const myNewFunc2 = outer();
myNewFunc2();
myNewFunc2();
```

### Execution Context Step-by-Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  outer: f{}                            ║
║  myNewFunc: ???                        ║
║  myNewFunc2: ???                       ║
╚════════════════════════════════════════╝
```

#### Step 2: First Call - `outer()`
```
CALL STACK:
┌─────────────────────────────────┐
│ outer()                         │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  outer() - FIRST CALL                  ║
        ╠════════════════════════════════════════╣
        ║  Variable Environment                  ║
        ║                                        ║
        ║  counter: 0                            ║
        ║  incrementCounter: f{}                 ║
        ║                                        ║
        ║  returns → incrementCounter            ║
        ╚════════════════════════════════════════╝
```

#### Step 3: After Return - Closure Created
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  outer: f{}                            ║
║                                        ║
║  myNewFunc: f{incrementCounter}        ║
║      ↓                                 ║
║  [[Closure]]: {counter: 0}             ║
║      ↑                                 ║
║  Backpack of data!                     ║
║                                        ║
╚════════════════════════════════════════╝
```

**CRITICAL:** When `incrementCounter` is returned, it brings along its **surrounding data** (the variable `counter`). This is the **CLOSURE**.

```
myNewFunc = function incrementCounter() {
                counter++;
            }
            +
            [[Closure]]: { counter: 0 }
```

The `[[Closure]]` is like a **backpack** attached to the function containing data from where it was defined.

#### Step 4: First Call - `myNewFunc()`
```
CALL STACK:
┌─────────────────────────────────┐
│ myNewFunc()                     │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  myNewFunc()                           ║
        ╠════════════════════════════════════════╣
        ║  Variable Environment (empty)          ║
        ║                                        ║
        ║  Looks for counter:                    ║
        ║  1. Local memory? NO                   ║
        ║  2. Closure? YES! Found counter: 0     ║
        ║                                        ║
        ║  counter++ → counter becomes 1         ║
        ╚════════════════════════════════════════╝

After execution:
╔════════════════════════════════════════╗
║  myNewFunc: f{incrementCounter}        ║
║  [[Closure]]: {counter: 1} ← UPDATED   ║
╚════════════════════════════════════════╝
```

#### Step 5: Second Call - `myNewFunc()`
```
        ╔════════════════════════════════════════╗
        ║  myNewFunc()                           ║
        ╠════════════════════════════════════════╣
        ║  Looks for counter in closure          ║
        ║  Found counter: 1                      ║
        ║  counter++ → counter becomes 2         ║
        ╚════════════════════════════════════════╝

After execution:
╔════════════════════════════════════════╗
║  myNewFunc: f{incrementCounter}        ║
║  [[Closure]]: {counter: 2} ← UPDATED   ║
╚════════════════════════════════════════╝
```

#### Step 6: Create Second Function - `outer()` again
```
CALL STACK:
┌─────────────────────────────────┐
│ outer() - SECOND CALL           │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  outer() - SECOND CALL                 ║
        ╠════════════════════════════════════════╣
        ║  counter: 0  ← BRAND NEW               ║
        ║  incrementCounter: f{}                 ║
        ║                                        ║
        ║  returns → incrementCounter            ║
        ╚════════════════════════════════════════╝

After return:
╔════════════════════════════════════════╗
║  myNewFunc: f{incrementCounter}        ║
║  [[Closure]]: {counter: 2}             ║
║                                        ║
║  myNewFunc2: f{incrementCounter}       ║
║  [[Closure]]: {counter: 0} ← NEW!      ║
║                                        ║
╚════════════════════════════════════════╝
```

**Important:** Each call to `outer()` creates a **completely separate closure** with its own `counter` variable.

#### Step 7: Calling `myNewFunc2()`
```
First call to myNewFunc2():
╔════════════════════════════════════════╗
║  myNewFunc2: f{incrementCounter}       ║
║  [[Closure]]: {counter: 1} ← UPDATED   ║
╚════════════════════════════════════════╝

Second call to myNewFunc2():
╔════════════════════════════════════════╗
║  myNewFunc2: f{incrementCounter}       ║
║  [[Closure]]: {counter: 2} ← UPDATED   ║
╚════════════════════════════════════════╝
```

**Final State:**
```
╔════════════════════════════════════════╗
║  myNewFunc: f{incrementCounter}        ║
║  [[Closure]]: {counter: 2}             ║
║                                        ║
║  myNewFunc2: f{incrementCounter}       ║
║  [[Closure]]: {counter: 2}             ║
║                                        ║
║  Two SEPARATE closures!                ║
╚════════════════════════════════════════╝
```

---

## How Does `myNewFunc()` Have Access to `counter`?

**Answer: Using SCOPE**

### What is Scope?

**Scope** determines where variables are accessible in your code.

**Scope Chain (Variable Lookup Order):**
1. Local Memory (Variable Environment)
2. Closure (variables from outer function)
3. Global Memory

```
╔════════════════════════════════════════╗
║  SCOPE CHAIN                           ║
╠════════════════════════════════════════╣
║                                        ║
║  1. Local Scope (own memory)           ║
║         ↓                              ║
║  2. Closure Scope (outer function)     ║
║         ↓                              ║
║  3. Global Scope (global memory)       ║
║                                        ║
╚════════════════════════════════════════╝
```

---

## Types of Scope

### 1. Global Scope
Variables declared outside any function.

```javascript
const globalVar = "I'm global";

function test() {
    console.log(globalVar); // Accessible
}
```

```
╔════════════════════════════════════════╗
║  GLOBAL SCOPE                          ║
║  globalVar: "I'm global"               ║
║  test: f{}                             ║
╚════════════════════════════════════════╝
```

### 2. Function Scope (Local Scope)
Variables declared inside a function.

```javascript
function test() {
    const localVar = "I'm local";
    console.log(localVar); // Accessible
}

console.log(localVar); // Error: localVar is not defined
```

```
╔════════════════════════════════════════╗
║  GLOBAL SCOPE                          ║
║  test: f{}                             ║
╠════════════════════════════════════════╣
║      ╔═══════════════════════════════╗ ║
║      ║  FUNCTION SCOPE (test)        ║ ║
║      ║  localVar: "I'm local"        ║ ║
║      ╚═══════════════════════════════╝ ║
╚════════════════════════════════════════╝
```

### 3. Block Scope
Variables declared with `let` or `const` inside `{}`.

```javascript
if (true) {
    let blockVar = "I'm in a block";
    console.log(blockVar); // Accessible
}

console.log(blockVar); // Error: blockVar is not defined
```

```
╔════════════════════════════════════════╗
║  GLOBAL SCOPE                          ║
╠════════════════════════════════════════╣
║      ╔═══════════════════════════════╗ ║
║      ║  BLOCK SCOPE (if)             ║ ║
║      ║  blockVar: "I'm in a block"   ║ ║
║      ╚═══════════════════════════════╝ ║
╚════════════════════════════════════════╝
```

### 4. Lexical Scope (Closure Scope)
Inner functions have access to outer function variables.

```javascript
function outer() {
    const outerVar = "outer";
    
    function inner() {
        console.log(outerVar); // Accessible via closure
    }
    
    return inner;
}
```

```
╔════════════════════════════════════════╗
║  GLOBAL SCOPE                          ║
║  outer: f{}                            ║
╠════════════════════════════════════════╣
║      ╔═══════════════════════════════╗ ║
║      ║  OUTER FUNCTION SCOPE         ║ ║
║      ║  outerVar: "outer"            ║ ║
║      ║  inner: f{}                   ║ ║
║      ╠═══════════════════════════════╣ ║
║      ║     ╔═══════════════════════╗ ║ ║
║      ║     ║ INNER FUNCTION SCOPE  ║ ║ ║
║      ║     ║ (can access outerVar) ║ ║ ║
║      ║     ╚═══════════════════════╝ ║ ║
║      ╚═══════════════════════════════╝ ║
╚════════════════════════════════════════╝
```

---

## Simple Scope Example

```javascript
const global = "global";

function outer() {
    const outerVar = "outer";
    
    function inner() {
        const innerVar = "inner";
        console.log(innerVar);  // Own scope
        console.log(outerVar);  // Parent scope (closure)
        console.log(global);    // Global scope
    }
    
    return inner;
}

const myFunc = outer();
myFunc();
```

**Variable Lookup for `inner`:**
1. Check local scope → `innerVar` found
2. Check closure scope → `outerVar` found
3. Check global scope → `global` found

---

## Is Closure Data Private?

**YES!** The only way to access closure variables is through the returned function.

```javascript
function createCounter() {
    let count = 0; // Private variable
    
    return function() {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2

// No way to access 'count' directly
console.log(count); // Error: count is not defined
```

**Benefits of Privacy:**
- Data protection (can't be accidentally modified)
- Encapsulation (hide implementation details)
- Controlled access (only through specific functions)

---

## Closures with Callback Functions

**YES**, callback functions have access to closures!

### Example: setTimeout with Closure

```javascript
function createGreeting(name) {
    const greeting = "Hello";
    
    setTimeout(function() {
        console.log(greeting + " " + name);
    }, 1000);
}

createGreeting("John");
// After 1 second: "Hello John"
```

### Execution Context

#### Step 1: Call `createGreeting("John")`
```
        ╔════════════════════════════════════════╗
        ║  createGreeting("John")                ║
        ╠════════════════════════════════════════╣
        ║  name: "John"                          ║
        ║  greeting: "Hello"                     ║
        ║                                        ║
        ║  setTimeout registers callback         ║
        ║  (callback gets closure)               ║
        ╚════════════════════════════════════════╝
```

#### Step 2: Function Completes - Callback Waits
```
╔════════════════════════════════════════╗
║  GLOBAL EXECUTION CONTEXT              ║
╠════════════════════════════════════════╣
║  createGreeting: f{}                   ║
║                                        ║
║  Callback waiting in Web API:          ║
║  function() {                          ║
║      console.log(greeting + " " + name)║
║  }                                     ║
║  [[Closure]]: {                        ║
║      name: "John",                     ║
║      greeting: "Hello"                 ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 3: After 1 Second - Callback Executes
```
        ╔════════════════════════════════════════╗
        ║  Callback Function                     ║
        ╠════════════════════════════════════════╣
        ║  Variable Environment (empty)          ║
        ║                                        ║
        ║  Accesses from closure:                ║
        ║  greeting: "Hello"                     ║
        ║  name: "John"                          ║
        ║                                        ║
        ║  Output: "Hello John"                  ║
        ╚════════════════════════════════════════╝
```

### Example: Array Methods with Closure

```javascript
function multiplyArray(arr, multiplier) {
    return arr.map(function(num) {
        return num * multiplier; // Accesses 'multiplier' from closure
    });
}

const result = multiplyArray([1, 2, 3], 10);
console.log(result); // [10, 20, 30]
```

**Execution:**
```
        ╔════════════════════════════════════════╗
        ║  multiplyArray([1,2,3], 10)            ║
        ╠════════════════════════════════════════╣
        ║  arr: [1, 2, 3]                        ║
        ║  multiplier: 10                        ║
        ║                                        ║
        ║  map callback gets closure:            ║
        ║  function(num) {                       ║
        ║      return num * multiplier;          ║
        ║  }                                     ║
        ║  [[Closure]]: { multiplier: 10 }       ║
        ╚════════════════════════════════════════╝
```

Each iteration of map:
```
Iteration 1: num=1, multiplier=10 → 10
Iteration 2: num=2, multiplier=10 → 20
Iteration 3: num=3, multiplier=10 → 30
```

---

## Unreferenced Variables in Closure

**Question:** If a variable in the lexical scope is never referenced in the inner function, is it included in the closure?

**Answer:** NO. JavaScript is smart and only includes variables that are **actually referenced** in the closure.

### Example 1: Only Referenced Variables
```javascript
function outer() {
    const used = "I'm used";
    const unused = "I'm not used";
    
    function inner() {
        console.log(used); // Only 'used' is referenced
    }
    
    return inner;
}

const myFunc = outer();
```

**Closure contains:**
```
myFunc [[Closure]]: {
    used: "I'm used"
    // 'unused' is NOT in closure
}
```

### Example 2: No References
```javascript
function outer() {
    const variable = "I'm never used";
    
    function inner() {
        console.log("Hello"); // Doesn't reference 'variable'
    }
    
    return inner;
}

const myFunc = outer();
```

**Closure contains:**
```
myFunc [[Closure]]: {
    // Empty! No variables referenced
}
```

### Example 3: Multiple Variables
```javascript
function outer() {
    const a = 1;
    const b = 2;
    const c = 3;
    
    function inner() {
        console.log(a + c); // Only references 'a' and 'c'
    }
    
    return inner;
}

const myFunc = outer();
```

**Closure contains:**
```
myFunc [[Closure]]: {
    a: 1,
    c: 3
    // 'b' is NOT in closure
}
```

**Why?** This is an **optimization**. JavaScript only stores what's necessary, saving memory.

---

## Summary

### What is a Closure?
A closure is when a function remembers variables from where it was defined, even after the outer function has finished executing.

### Key Points:
1. **Closures provide permanent memory** for functions
2. Functions carry their **lexical scope** (closure) wherever they go
3. Closure is like a **backpack** of data attached to the function
4. Each function call creates a **separate, independent closure**
5. Variable lookup order: **Local → Closure → Global**
6. Closure data is **private** - only accessible through the function
7. **Callback functions** have access to closures
8. Only **referenced variables** are included in closures (optimization)

### Benefits of Closures:
- **Data persistence** without global variables
- **Private variables** and encapsulation
- **Factory functions** that create customized functions
- **Callbacks** that remember context
- **Module pattern** for organizing code

### Common Use Cases:
- Data privacy and encapsulation
- Factory functions
- Event handlers
- Callbacks (setTimeout, event listeners)
- Functional programming patterns (currying, partial application)
- Module pattern