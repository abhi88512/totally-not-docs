# 35\. Search Insert Position (LeetCode)

> Given a sorted array and a target value, find the index of the target. If the target is not found, return the index where it would be inserted to maintain the sorted order. The solution must run in $O(\log n)$ time.

-----

## 📝 Problem Description

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with $O(\log n)$ runtime complexity.

**Example 1:**

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

**Example 2:**

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

**Example 3:**

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```

-----

## 💡 Approach: Standard Binary Search

This problem is a classic application of binary search. The goal is to find the target's position or, if it's not present, the correct insertion point. We can use a standard binary search loop (`while (start <= end)`) to progressively narrow down the search space.

The key insight for this particular problem lies in what happens when the loop terminates. When the `while (start <= end)` loop finishes, the `start` pointer will always be pointing to the first element that is greater than the `target`. This is precisely the correct insertion position.

Let's break down the logic:

  * If `nums[mid] == target`, we've found the element, and we return its index `mid`.
  * If `nums[mid] > target`, the target must be in the left half of the current search space. We update `end = mid - 1`. The `start` pointer remains where it is, still potentially pointing to the correct insertion index.
  * If `nums[mid] < target`, the target must be in the right half of the current search space. We update `start = mid + 1`. This is the most crucial part. The `start` pointer is being pushed past all elements that are less than or equal to the target.

When the loop ends (`start > end`), the `start` pointer will be at the index where the target should be inserted. This holds true for all cases:

  * If the target is found, the function returns early.
  * If the target is smaller than all elements, `start` remains 0.
  * If the target is larger than all elements, `start` is pushed to `nums.size()`.
  * If the target is in the middle, `start` will land at the correct spot.

-----

## 🚶 Algorithm Steps

1.  Initialize two pointers: `start = 0` and `end = nums.size() - 1`.
2.  Begin a `while` loop that runs as long as `start <= end`.
3.  Inside the loop, calculate the `mid` index: `mid = start + (end - start) / 2`.
4.  Compare `nums[mid]` with `target`:
      * If `nums[mid] == target`, return `mid`. The target is found.
      * If `nums[mid] > target`, the target must be in the left half. Update `end = mid - 1`.
      * If `nums[mid] < target`, the target must be in the right half. Update `start = mid + 1`.
5.  If the loop completes without finding the target, the `start` pointer will hold the correct insertion index. Return `start`.

-----

## 💻 Example Walkthrough

Let's trace the algorithm with `nums = [1,3,5,6]` and `target = 2`.

1.  **Initial:** `start = 0`, `end = 3`. `nums = [1,3,5,6]`.

2.  **Iteration 1:**

      * `start <= end` (0 \<= 3) is true.
      * `mid = 0 + (3-0)/2 = 1`. `nums[mid]` (`nums[1]`) is `3`.
      * Compare `nums[mid] > target` (3 \> 2) is true.
      * `end = mid - 1 = 1 - 1 = 0`.
      * Current state: `start = 0`, `end = 0`.

3.  **Iteration 2:**

      * `start <= end` (0 \<= 0) is true.
      * `mid = 0 + (0-0)/2 = 0`. `nums[mid]` (`nums[0]`) is `1`.
      * Compare `nums[mid] > target` (1 \> 2) is false.
      * Compare `nums[mid] < target` (1 \< 2) is true.
      * `start = mid + 1 = 0 + 1 = 1`.
      * Current state: `start = 1`, `end = 0`.

4.  **Loop Termination:**

      * `start <= end` (1 \<= 0) is false. The loop terminates.

5.  **Return:** The value of `start`, which is **1**. This is the correct insertion index.

-----

## 📏 Constraints

  * `1 <= nums.length <= 10^4`
  * `-10^4 <= nums[i] <= 10^4`
  * `nums` contains distinct values sorted in ascending order.
  * `-10^4 <= target <= 10^4`

-----

## ⏱️ Complexity Analysis

  * **Time Complexity**: $O(\\log n)$, where `n` is the number of elements in the array. This is the inherent time complexity of a binary search algorithm.
  * **Space Complexity**: $O(1)$, as the algorithm uses a constant amount of auxiliary space for pointers (`start`, `end`, `mid`).

-----

## 🔑 Key Idea

The problem is solved using a standard binary search implementation. The crucial insight is that the `start` pointer naturally converges to the correct insertion index if the target is not found. Throughout the search, the `start` pointer is always pointing to an element that is greater than or equal to the target. When the search space is exhausted and `start > end`, `start` points to the precise location where the target would be inserted to maintain the sorted order.

-----

## 💻 Class Implementation

```cpp
#include <vector>

class Solution {
public:
    int searchInsert(std::vector<int>& nums, int target) {
        int start = 0;
        int end = nums.size() - 1;
        
        while(start <= end) {
            int mid = start + (end - start) / 2;
            
            if(nums[mid] == target) {
                return mid; // Target found
            }
            else if(nums[mid] > target) {
                end = mid - 1; // Target is in the left half
            }
            else { // nums[mid] < target
                start = mid + 1; // Target is in the right half
            }
        }
        
        // When the loop terminates, 'start' holds the correct insertion index.
        return start;
    }
};
```

-----

**Last Updated:** August 2, 2025

**Documentation Source:** [LeetCode 35. Search Insert Position](https://leetcode.com/problems/search-insert-position/description/)