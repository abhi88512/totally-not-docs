# JavaScript Promises - Complete Guide

## What are Promises?

**Promise** is a special JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value.

**Simple Definition:** A promise is a placeholder for a value that we don't have yet but will have in the future.

---

## Why Were Promises Created?

### Problems with Callbacks (setTimeout):

#### Problem 1: No Way to Track in JavaScript

```javascript
setTimeout(() => {
    console.log("Done");
}, 1000);

// Question: How do we know when this completes?
// Answer: We can't! No JavaScript object tracks this.
```

**Issues:**
- No way to check status in JavaScript
- No way to know if it succeeded or failed
- No JavaScript object to interact with
- Everything happens in the browser

#### Problem 2: Callback Hell

```javascript
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            getMoreData(c, function(d) {
                // Pyramid of doom
            });
        });
    });
});
```

#### Problem 3: Inversion of Control

```javascript
// We pass our function to setTimeout
// We lose control over when it executes
setTimeout(myFunction, 1000);

// What if the browser doesn't call it?
// What if it calls it twice?
// We have no control!
```

### How Promises Solve These Problems:

1. **Trackable in JavaScript** - Promise object exists in JS memory
2. **Better Syntax** - Chain with `.then()` instead of nesting
3. **Control** - We control when to use the result
4. **Error Handling** - Built-in `.catch()` for errors
5. **Guaranteed Execution** - Promises execute exactly once

---

## Promises vs setTimeout

### setTimeout (0ms) - No Tracking
```javascript
setTimeout(() => {
    console.log("Data");
}, 0);

// No JavaScript object to track this
// No way to know when it completes
// No way to use the result later
```

### Promise - Fully Trackable
```javascript
const futureData = fetch(url);

// futureData is a REAL JavaScript object
// We can check its status
// We can use .then() to handle result
// We have full control
```

**Key Difference:** Promise gives us a JavaScript object that tracks the async operation.

---

## Example 1: Basic Promise

```javascript
function display(data) {
    console.log(data);
}

const futureData = fetch('https://twitter.com/will/tweets/1');

futureData.then(display);

console.log("Me First!!");
```

### Execution Context - Step by Step

#### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  MEMORY                                ║
║                                        ║
║  display: f{}                          ║
║  futureData: ???                       ║
║                                        ║
╚════════════════════════════════════════╝

CALL STACK:
┌─────────────────────┐
│ Global              │
└─────────────────────┘
```

#### Step 2: Execute `fetch()`
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  display: f{}                          ║
║                                        ║
║  futureData: Promise {                 ║
║      value: undefined                  ║
║      status: 'pending'                 ║
║      onFulfillment: []                 ║
║  }                                     ║
╚════════════════════════════════════════╝

WEB BROWSER:
┌─────────────────────────────────────────┐
│ Network Request:                        │
│ GET https://twitter.com/will/tweets/1   │
│ Status: In Progress...                  │
└─────────────────────────────────────────┘
```

**Important:** `fetch()` immediately returns a Promise object with:
- `value`: undefined (data not here yet)
- `status`: 'pending' (waiting for response)
- `onFulfillment`: [] (empty array for functions to run when complete)

#### Step 3: Execute `futureData.then(display)`
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  display: f{}                          ║
║                                        ║
║  futureData: Promise {                 ║
║      value: undefined                  ║
║      status: 'pending'                 ║
║      onFulfillment: [display]          ║
║        ↑                               ║
║   display function added to array!     ║
║  }                                     ║
╚════════════════════════════════════════╝
```

**What `.then()` does:**
- Takes a function (display)
- Adds it to the `onFulfillment` array
- Does NOT execute it yet
- Waits for promise to resolve

#### Step 4: Execute `console.log("Me First!!")`
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  Thread of Execution:                  ║
║  → console.log("Me First!!")           ║
║                                        ║
║  Output: "Me First!!"                  ║
╚════════════════════════════════════════╝

WEB BROWSER (still working):
┌─────────────────────────────────────────┐
│ Network Request: Still waiting...      │
└─────────────────────────────────────────┘
```

#### Step 5: Network Request Completes (after 270ms)
```
WEB BROWSER:
┌─────────────────────────────────────────┐
│ Network Request: COMPLETE!              │
│ Response: {tweets: [...]}               │
│ Sending data back to JavaScript...     │
└─────────────────────────────────────────┘
        ↓
╔════════════════════════════════════════╗
║  futureData: Promise {                 ║
║      value: {tweets: [...]}            ║
║           ↑                            ║
║      Data automatically filled!        ║
║                                        ║
║      status: 'fulfilled'               ║
║           ↑                            ║
║      Status automatically updated!     ║
║                                        ║
║      onFulfillment: [display]          ║
║  }                                     ║
╚════════════════════════════════════════╝

MICROTASK QUEUE:
┌─────────────────────────────────────────┐
│ display({tweets: [...]})                │
│    ↑                                    │
│ Automatically added to microtask queue! │
└─────────────────────────────────────────┘
```

#### Step 6: Event Loop Executes Microtask
```
CALL STACK (empty):
┌─────────────────────┐
│ (empty)             │
└─────────────────────┘

EVENT LOOP: "Call stack empty! Check microtasks..."

MICROTASK QUEUE:
┌─────────────────────────────────────────┐
│ display({tweets: [...]})                │ → Move to stack
└─────────────────────────────────────────┘

CALL STACK:
┌─────────────────────────┐
│ display({tweets: [...]})│ ← Executing
└─────────────────────────┘

Output: {tweets: [...]}
```

**Output Order:**
```
Me First!!
{tweets: [...]}
```

---

## Promise Object Structure

### Promise Object Properties

```javascript
const promise = fetch(url);

// Internal structure:
promise = {
    value: undefined,           // The actual data
    status: 'pending',          // 'pending', 'fulfilled', or 'rejected'
    onFulfillment: [],         // Array of functions to run on success
    onRejection: []            // Array of functions to run on failure
}
```

### Property Details:

#### 1. `value`
- Stores the result of the async operation
- Initially `undefined`
- Automatically filled when operation completes
- **Immutable** - can only be set once

#### 2. `status` (also called `state`)
- **'pending'** - Initial state, operation in progress
- **'fulfilled'** - Operation completed successfully
- **'rejected'** - Operation failed with error

```
┌─────────┐
│ pending │
└────┬────┘
     │
     ├─── Success ──→ ┌───────────┐
     │                 │ fulfilled │
     │                 └───────────┘
     │
     └─── Failure ──→ ┌──────────┐
                       │ rejected │
                       └──────────┘
```

#### 3. `onFulfillment` (hidden property)
- Array of functions to execute when promise fulfills
- Functions added via `.then()`
- Automatically triggered when `value` is set

#### 4. `onRejection` (hidden property)
- Array of functions to execute when promise rejects
- Functions added via `.catch()` or second argument of `.then()`
- Automatically triggered on error

### Visual Representation:

```
╔═══════════════════════════════════════════╗
║          PROMISE OBJECT                   ║
╠═══════════════════════════════════════════╣
║                                           ║
║  value: undefined → {data}                ║
║         (auto-filled by browser)          ║
║                                           ║
║  status: 'pending' → 'fulfilled'          ║
║          (auto-updated by browser)        ║
║                                           ║
║  onFulfillment: [func1, func2]            ║
║                 (we add via .then)        ║
║                                           ║
║  onRejection: [errorHandler]              ║
║               (we add via .catch)         ║
║                                           ║
╚═══════════════════════════════════════════╝
```

---

## What is a Network Request?

### Network Request Basics

**Network Request** is asking a server for data over the internet.

```
┌──────────────┐           ┌──────────────┐
│   Browser    │  Request  │    Server    │
│              │ ────────→ │              │
│              │           │ twitter.com  │
│              │ ←──────── │              │
│              │  Response │              │
└──────────────┘           └──────────────┘
```

### What `fetch()` Does:

1. **Creates Promise Object** in JavaScript
2. **Sends Network Request** via browser
3. **Returns Promise Immediately** (doesn't wait)
4. **Browser handles request** independently
5. **Promise auto-updates** when response arrives

```javascript
const promise = fetch('https://api.example.com/data');

// Step 1: Promise created immediately
// promise = {value: undefined, status: 'pending'}

// Step 2: Browser sends request
// Step 3: JavaScript continues (doesn't wait)

// Step 4: When response arrives (later)
// promise = {value: {data}, status: 'fulfilled'}
```

### What `.then()` Does:

**Purpose:** Register a function to run when promise fulfills.

```javascript
promise.then(onSuccess);

// Equivalent to:
// promise.onFulfillment.push(onSuccess);
```

**Behavior:**
- Does NOT execute the function immediately
- Adds function to the promise's `onFulfillment` array
- Function executes automatically when promise resolves
- Function goes to **microtask queue**, not callback queue

### What `.catch()` Does:

**Purpose:** Register a function to run if promise rejects.

```javascript
promise.catch(onError);

// Equivalent to:
// promise.onRejection.push(onError);
```

### How Promise-Deferred Functions Return to JavaScript:

```
╔═══════════════════════════════════════════╗
║  1. PROMISE CREATED IN JAVASCRIPT         ║
╠═══════════════════════════════════════════╣
║  const promise = fetch(url);              ║
║  promise.then(handleData);                ║
╚═══════════════════════════════════════════╝
                ↓
╔═══════════════════════════════════════════╗
║  2. BROWSER HANDLES REQUEST               ║
╠═══════════════════════════════════════════╣
║  Network request sent...                  ║
║  (JavaScript continues executing)         ║
╚═══════════════════════════════════════════╝
                ↓
╔═══════════════════════════════════════════╗
║  3. RESPONSE ARRIVES IN BROWSER           ║
╠═══════════════════════════════════════════╣
║  Browser updates promise object:          ║
║    - promise.value = responseData         ║
║    - promise.status = 'fulfilled'         ║
╚═══════════════════════════════════════════╝
                ↓
╔═══════════════════════════════════════════╗
║  4. AUTO-TRIGGER FULFILLMENT FUNCTIONS    ║
╠═══════════════════════════════════════════╣
║  All functions in onFulfillment array     ║
║  are added to MICROTASK QUEUE             ║
╚═══════════════════════════════════════════╝
                ↓
╔═══════════════════════════════════════════╗
║  5. EVENT LOOP EXECUTES                   ║
╠═══════════════════════════════════════════╣
║  When call stack empty:                   ║
║    - Check microtask queue                ║
║    - Execute handleData(responseData)     ║
╚═══════════════════════════════════════════╝
```

---

## Example 2: Complex Execution Order

```javascript
function display(data) {
    console.log(data);
}

function printHello() {
    console.log('Hello');
}

function blockFor300ms() {
    // Blocks JavaScript for 300ms
}

setTimeout(printHello, 0);

const futureData = fetch('https://twitter.com/will/tweets/1');

futureData.then(display);

blockFor300ms();

console.log("Me First!!");
```

### Execution Context - Step by Step

#### Step 1: Global Setup (0ms)
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  display: f{}                          ║
║  printHello: f{}                       ║
║  blockFor300ms: f{}                    ║
║  futureData: ???                       ║
╚════════════════════════════════════════╝

CALL STACK:
┌─────────────────────┐
│ Global              │
└─────────────────────┘
```

#### Step 2: Execute `setTimeout(printHello, 0)` (0ms)
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  (functions stored)                    ║
║  futureData: ???                       ║
╚════════════════════════════════════════╝

WEB BROWSER:
┌─────────────────────────────────────────┐
│ Timer: printHello (0ms)                 │
│ Waiting...                              │
└─────────────────────────────────────────┘

After 0ms →
CALLBACK QUEUE (Macrotask):
┌─────────────────────────────────────────┐
│ printHello                              │
└─────────────────────────────────────────┘
```

#### Step 3: Execute `fetch()` (1ms)
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  futureData: Promise {                 ║
║      value: undefined                  ║
║      status: 'pending'                 ║
║      onFulfillment: []                 ║
║  }                                     ║
╚════════════════════════════════════════╝

WEB BROWSER:
┌─────────────────────────────────────────┐
│ Timer: printHello (DONE - in queue)     │
│                                         │
│ Network Request: In Progress...         │
│ GET https://twitter.com/will/tweets/1   │
└─────────────────────────────────────────┘
```

#### Step 4: Execute `futureData.then(display)` (2ms)
```
╔════════════════════════════════════════╗
║  futureData: Promise {                 ║
║      value: undefined                  ║
║      status: 'pending'                 ║
║      onFulfillment: [display]          ║
║           ↑                            ║
║      display added to array!           ║
║  }                                     ║
╚════════════════════════════════════════╝
```

#### Step 5: Execute `blockFor300ms()` (3ms - 303ms)
```
CALL STACK:
┌─────────────────────┐
│ blockFor300ms()     │ ← BLOCKING for 300ms
├─────────────────────┤
│ Global              │
└─────────────────────┘

During these 300ms:
- JavaScript is BLOCKED
- No other code runs
- printHello waiting in callback queue
- Network request continues in browser
```

#### Step 6: Network Completes During Block (270ms)
```
WEB BROWSER (270ms):
┌─────────────────────────────────────────┐
│ Network Request: COMPLETE!              │
│ Response: {tweets: [...]}               │
└─────────────────────────────────────────┘
        ↓
╔════════════════════════════════════════╗
║  futureData: Promise {                 ║
║      value: {tweets: [...]}            ║
║      status: 'fulfilled'               ║
║      onFulfillment: [display]          ║
║  }                                     ║
╚════════════════════════════════════════╝

MICROTASK QUEUE (270ms):
┌─────────────────────────────────────────┐
│ display({tweets: [...]})                │
└─────────────────────────────────────────┘

CALLBACK QUEUE (Macrotask):
┌─────────────────────────────────────────┐
│ printHello                              │
└─────────────────────────────────────────┘

NOTE: JavaScript still blocked!
Can't execute anything from queues yet!
```

#### Step 7: `blockFor300ms()` Completes (303ms)
```
CALL STACK:
┌─────────────────────┐
│ Global              │ ← Block function returned
└─────────────────────┘
```

#### Step 8: Execute `console.log("Me First!!")` (304ms)
```
Output: "Me First!!"

CALL STACK:
┌─────────────────────┐
│ (empty)             │
└─────────────────────┘

MICROTASK QUEUE:
┌─────────────────────────────────────────┐
│ display({tweets: [...]})                │
└─────────────────────────────────────────┘

CALLBACK QUEUE:
┌─────────────────────────────────────────┐
│ printHello                              │
└─────────────────────────────────────────┘
```

#### Step 9: Event Loop - Execute Microtask (305ms)
```
EVENT LOOP: "Call stack empty!"
EVENT LOOP: "Check microtask queue first..."

CALL STACK:
┌─────────────────────────┐
│ display({tweets: [...]})│ ← From microtask queue
└─────────────────────────┘

Output: {tweets: [...]}
```

#### Step 10: Event Loop - Execute Macrotask (306ms)
```
EVENT LOOP: "Microtasks done!"
EVENT LOOP: "Now check callback queue..."

CALL STACK:
┌─────────────────────┐
│ printHello()        │ ← From callback queue
└─────────────────────┘

Output: "Hello"
```

### Final Output Order:
```
Me First!!
{tweets: [...]}
Hello
```

### Timeline Visualization:

```
Time:  0ms    270ms   303ms   304ms   305ms   306ms
       │      │       │       │       │       │
       │      │       │       │       │       │
       ├──────┼───────┼───────┼───────┼───────┤
       │      │       │       │       │       │
setTimeout─────→ (in callback queue)
       │
fetch──→ (request sent)
       │      │
       │  Response arrives
       │      └──→ (display in microtask queue)
       │
       │      │       │
       └──────┴───────→ blockFor300ms (BLOCKING)
                       │
                       └──→ console.log("Me First!!")
                              │
                              └──→ display (microtask)
                                     │
                                     └──→ printHello (macrotask)
```

---

## Callback Queue vs Microtask Queue

### Comparison Table

| Feature | Callback Queue (Macrotask) | Microtask Queue |
|---------|---------------------------|-----------------|
| **Priority** | Lower | Higher |
| **Execution** | ONE per event loop cycle | ALL before next macrotask |
| **Sources** | setTimeout, setInterval, I/O, UI rendering | Promises (.then/.catch), async/await, queueMicrotask(), MutationObserver |
| **Processing** | One task, then check microtasks | All tasks, then one macrotask |

### Which Browser Features Go Where?

#### Macrotask Queue (Callback Queue):
```javascript
// setTimeout
setTimeout(callback, delay);

// setInterval
setInterval(callback, delay);

// setImmediate (Node.js only)
setImmediate(callback);

// I/O operations
fs.readFile(path, callback);

// UI rendering tasks
requestAnimationFrame(callback);
```

#### Microtask Queue:
```javascript
// Promise.then()
promise.then(callback);

// Promise.catch()
promise.catch(callback);

// Promise.finally()
promise.finally(callback);

// async/await (uses promises internally)
async function() {
    await promise;
}

// queueMicrotask
queueMicrotask(callback);

// MutationObserver
const observer = new MutationObserver(callback);
```

### Visual Representation

```
╔═══════════════════════════════════════════╗
║           EVENT LOOP PRIORITY             ║
╠═══════════════════════════════════════════╣
║                                           ║
║  1. CALL STACK (current execution)        ║
║     └─→ Execute until empty               ║
║                                           ║
║  2. MICROTASK QUEUE (HIGH priority)       ║
║     ├─→ Promise.then()                    ║
║     ├─→ Promise.catch()                   ║
║     ├─→ async/await                       ║
║     ├─→ queueMicrotask()                  ║
║     └─→ Execute ALL microtasks            ║
║                                           ║
║  3. MACROTASK QUEUE (LOWER priority)      ║
║     ├─→ setTimeout                        ║
║     ├─→ setInterval                       ║
║     ├─→ I/O operations                    ║
║     └─→ Execute ONE macrotask             ║
║                                           ║
║  4. GO BACK TO STEP 1                     ║
║                                           ║
╚═══════════════════════════════════════════╝
```

### Example: Queue Priority

```javascript
console.log('1. Sync');

setTimeout(() => console.log('2. Macrotask'), 0);

Promise.resolve().then(() => console.log('3. Microtask 1'));

Promise.resolve().then(() => console.log('4. Microtask 2'));

console.log('5. Sync');
```

**Output:**
```
1. Sync
5. Sync
3. Microtask 1
4. Microtask 2
2. Macrotask
```

**Why?**
```
Step 1: Execute all sync code (1, 5)
Step 2: Execute ALL microtasks (3, 4)
Step 3: Execute ONE macrotask (2)
```

---

## Do Promises Run After All Sync Code?

**Answer: YES, but with priority over setTimeout**

### Execution Order:

1. **All Synchronous Code** (runs first)
2. **All Microtasks** (promises, async/await)
3. **One Macrotask** (setTimeout, setInterval)
4. **Repeat**

### Example:

```javascript
console.log('Sync 1');

setTimeout(() => console.log('Timeout'), 0);

Promise.resolve().then(() => console.log('Promise'));

console.log('Sync 2');

// Output:
// Sync 1
// Sync 2
// Promise    ← After sync, before setTimeout
// Timeout
```

**Proof:**
```
Timeline:
[0ms]   "Sync 1" (synchronous)
[0ms]   setTimeout scheduled (goes to macrotask queue)
[0ms]   Promise resolved (goes to microtask queue)
[0ms]   "Sync 2" (synchronous)
[0ms]   Call stack empty
[0ms]   Execute ALL microtasks → "Promise"
[0ms]   Execute ONE macrotask → "Timeout"
```

---

## Can `.then()` Take Multiple Arguments?

**Answer: YES**

### Syntax:

```javascript
promise.then(onFulfilled, onRejected);
```

### Arguments:

1. **First argument**: Success handler (when promise fulfills)
2. **Second argument**: Error handler (when promise rejects)

### Example:

```javascript
const promise = fetch(url);

promise.then(
    // Success handler (onFulfilled)
    (data) => {
        console.log('Success:', data);
    },
    
    // Error handler (onRejected)
    (error) => {
        console.log('Error:', error);
    }
);
```

### Equivalent to:

```javascript
promise
    .then((data) => console.log('Success:', data))
    .catch((error) => console.log('Error:', error));
```

### Important Notes:

- Both arguments are optional
- Second argument handles errors from the promise only
- `.catch()` is preferred for readability
- `.catch()` handles errors from previous `.then()` too

---

## Does Event Loop Check Microtask Queue?

**Answer: YES, and it checks it BEFORE the callback queue**

### Event Loop Algorithm:

```
╔═══════════════════════════════════════════╗
║        EVENT LOOP ALGORITHM               ║
╠═══════════════════════════════════════════╣
║                                           ║
║  while (true) {                           ║
║                                           ║
║    1. Execute current task in call stack  ║
║                                           ║
║    2. If call stack empty:                ║
║                                           ║
║       a) Check MICROTASK QUEUE            ║
║          - Execute ALL microtasks         ║
║          - Repeat until queue empty       ║
║                                           ║
║       b) Check CALLBACK QUEUE             ║
║          - Execute ONE macrotask          ║
║                                           ║
║    3. Repeat                              ║
║                                           ║
║  }                                        ║
║                                           ║
╚═══════════════════════════════════════════╝
```

### Visual Flow:

```
┌─────────────────┐
│   Call Stack    │
│   Empty?        │
└────────┬────────┘
         │
         ↓ YES
┌─────────────────────────┐
│ Microtask Queue Empty?  │
└────────┬───────┬────────┘
         │       │
    NO   │       │ YES
         ↓       ↓
┌─────────────┐  ┌──────────────────────┐
│  Execute    │  │ Callback Queue Empty?│
│  ALL        │  └────────┬──────┬──────┘
│  Microtasks │           │      │
└─────────────┘      NO   │      │ YES
         │                ↓      ↓
         └──────→  ┌──────────┐  ┌────────┐
                   │ Execute  │  │  Wait  │
                   │   ONE    │  │        │
                   │ Macrotask│  └────────┘
                   └──────────┘
```

---

## Rules for Running Promise-Deferred Functions

### The Five Rules:

#### Rule 1: Promises Create Microtasks
```javascript
promise.then(callback);
// callback goes to MICROTASK QUEUE
// NOT callback queue
```

#### Rule 2: Microtasks Execute Before Macrotasks
```javascript
setTimeout(() => console.log('Macro'), 0);
Promise.resolve().then(() => console.log('Micro'));

// Output: Micro, then Macro
```

#### Rule 3: ALL Microtasks Execute Before Next Macrotask
```javascript
Promise.resolve().then(() => console.log('Micro 1'));
Promise.resolve().then(() => console.log('Micro 2'));
Promise.resolve().then(() => console.log('Micro 3'));
setTimeout(() => console.log('Macro'), 0);

// Output: Micro 1, Micro 2, Micro 3, Macro
```

#### Rule 4: Microtasks Can Create New Microtasks
```javascript
Promise.resolve().then(() => {
    console.log('Micro 1');
    Promise.resolve().then(() => console.log('Micro 2'));
});

// All execute before any macrotask
// Output: Micro 1, Micro 2
```

#### Rule 5: Call Stack Must Be Empty
```javascript
function block() {
    // Blocks for 1 second
}

Promise.resolve().then(() => console.log('Promise'));
block(); // Blocks
console.log('Sync');

// Promise waits for call stack to empty
// Output: Sync, then Promise
```

### Summary of Rules:

```
╔═══════════════════════════════════════════╗
║    PROMISE-DEFERRED FUNCTION RULES        ║
╠═══════════════════════════════════════════╣
║                                           ║
║  1. .then() callbacks → Microtask Queue   ║
║                                           ║
║  2. Microtasks execute before macrotasks  ║
║                                           ║
║  3. ALL microtasks run before ONE macro   ║
║                                           ║
║  4. Microtasks can create more microtasks ║
║                                           ║
║  5. Call stack must be empty first        ║
║                                           ║
╚═══════════════════════════════════════════╝
```

---

## Can Event Loop Never Check Callback Queue?

**Answer: YES! This is called "Microtask Queue Starvation"**

### The Scenario: Infinite Microtask Loop

If microtasks keep creating new microtasks, the event loop will NEVER get to check the callback queue (macrotask queue).

### Example: Starving the Callback Queue

```javascript
console.log('Start');

// Macrotask - goes to callback queue
setTimeout(() => {
    console.log('I will NEVER run!');
}, 0);

// Microtask that creates another microtask
function createMicrotask() {
    Promise.resolve().then(() => {
        console.log('Microtask running...');
        createMicrotask(); // Creates another microtask!
    });
}

createMicrotask();

console.log('End');
```

**Output:**
```
Start
End
Microtask running...
Microtask running...
Microtask running...
Microtask running...
(infinite loop - setTimeout NEVER executes)
```

### Execution Context:

#### Step 1: Synchronous Code
```
CALL STACK:
┌─────────────────────┐
│ Global              │
└─────────────────────┘

Output: "Start"
Output: "End"

CALLBACK QUEUE (Macrotask):
┌─────────────────────────────────────────┐
│ () => console.log('I will NEVER run!')  │
└─────────────────────────────────────────┘

MICROTASK QUEUE:
┌─────────────────────────────────────────┐
│ First microtask from createMicrotask()  │
└─────────────────────────────────────────┘
```

#### Step 2: Execute First Microtask
```
CALL STACK:
┌─────────────────────────┐
│ Microtask function      │
└─────────────────────────┘

Output: "Microtask running..."

Creates another microtask!

MICROTASK QUEUE:
┌─────────────────────────────────────────┐
│ New microtask (just created)            │
└─────────────────────────────────────────┘
```

#### Step 3: Execute New Microtask (and so on...)
```
EVENT LOOP: "Call stack empty, check microtasks..."
EVENT LOOP: "Found microtask! Execute it..."
    → Executes microtask
    → Creates another microtask
EVENT LOOP: "Still have microtasks! Execute them..."
    → Executes microtask
    → Creates another microtask
EVENT LOOP: "Still have microtasks! Execute them..."
    (INFINITE LOOP)

CALLBACK QUEUE:
┌─────────────────────────────────────────┐
│ setTimeout callback (WAITING FOREVER)   │
└─────────────────────────────────────────┘
     ↑
Event loop NEVER gets here!
```

### Visual Timeline:

```
┌──────────────────────────────────────────────┐
│  Event Loop Cycle                            │
├──────────────────────────────────────────────┤
│                                              │
│  1. Execute sync code                        │
│  2. Check microtask queue                    │
│     → Execute microtask                      │
│     → New microtask added                    │
│  3. Check microtask queue AGAIN              │
│     → Execute microtask                      │
│     → New microtask added                    │
│  4. Check microtask queue AGAIN              │
│     → Execute microtask                      │
│     → New microtask added                    │
│                                              │
│  ... INFINITE LOOP ...                       │
│                                              │
│  NEVER REACHES: Check callback queue         │
│                                              │
└──────────────────────────────────────────────┘
```

### Practical Example: Accidental Starvation

```javascript
console.log('Start');

setTimeout(() => console.log('Timeout'), 0);

// Process array with promises
const arr = new Array(1000000).fill(0);

function processArray(index) {
    if (index >= arr.length) return;
    
    Promise.resolve().then(() => {
        // Process item
        console.log(`Processing ${index}`);
        processArray(index + 1); // Creates new microtask
    });
}

processArray(0);

console.log('End');
```

**Result:**
- Processes entire array (1,000,000 items)
- Each creates a new microtask
- setTimeout never executes until ALL array items processed
- Callback queue is starved for a long time

### Why This Happens:

```
╔═══════════════════════════════════════════╗
║     EVENT LOOP PRIORITY                   ║
╠═══════════════════════════════════════════╣
║                                           ║
║  while (true) {                           ║
║                                           ║
║    if (callStack.isEmpty()) {             ║
║                                           ║
║      // This runs FIRST                   ║
║      while (microtaskQueue.hasTask()) {   ║
║        execute(microtaskQueue.next());    ║
║      }                                    ║
║      ↑                                    ║
║      If microtasks keep adding more,      ║
║      this loop NEVER exits!               ║
║                                           ║
║      // This NEVER runs if above loops    ║
║      if (callbackQueue.hasTask()) {       ║
║        execute(callbackQueue.next());     ║
║      }                                    ║
║                                           ║
║    }                                      ║
║  }                                        ║
║                                           ║
╚═══════════════════════════════════════════╝
```

### Comparison: Macrotasks Don't Starve

```javascript
// Macrotasks DON'T starve each other
function createTimeout() {
    setTimeout(() => {
        console.log('Timeout');
        createTimeout(); // Creates another timeout
    }, 0);
}

createTimeout();

setTimeout(() => {
    console.log('Other timeout WILL run');
}, 0);
```

**Why?**
- Only ONE macrotask executes per cycle
- Event loop checks microtasks between each macrotask
- All macrotasks get their turn eventually

### Solution: Break Up Microtasks

**Bad (Starves callback queue):**
```javascript
function processAll(arr, index = 0) {
    if (index >= arr.length) return;
    
    Promise.resolve().then(() => {
        process(arr[index]);
        processAll(arr, index + 1);
    });
}
```

**Good (Allows callback queue to run):**
```javascript
function processChunk(arr, index = 0) {
    // Process chunk of 100 items
    const end = Math.min(index + 100, arr.length);
    
    for (let i = index; i < end; i++) {
        process(arr[i]);
    }
    
    if (end < arr.length) {
        // Use setTimeout to give callback queue a chance
        setTimeout(() => processChunk(arr, end), 0);
    }
}
```

### Key Takeaway:

```
╔═══════════════════════════════════════════╗
║           MICROTASK STARVATION            ║
╠═══════════════════════════════════════════╣
║                                           ║
║  YES - Event loop can never reach         ║
║  callback queue if:                       ║
║                                           ║
║  - Microtasks keep creating microtasks    ║
║  - Creates infinite microtask loop        ║
║  - Macrotasks wait forever                ║
║                                           ║
║  This is called:                          ║
║  "Microtask Queue Starvation" or          ║
║  "Macrotask Starvation"                   ║
║                                           ║
╚═══════════════════════════════════════════╝
```

---

## Complete Summary

### What are Promises?

Promises are JavaScript objects that represent the eventual completion (or failure) of asynchronous operations.

### Why Were They Created?

1. **Trackability** - Unlike setTimeout, promises exist in JavaScript memory
2. **Better Syntax** - Chain with .then() instead of nested callbacks
3. **Control** - We control when to use results
4. **Error Handling** - Built-in .catch() for errors
5. **Guaranteed Execution** - Execute exactly once

### Key Differences from setTimeout:

| Feature | setTimeout | Promise |
|---------|-----------|---------|
| **Tracking** | No JavaScript object | Promise object in memory |
| **Queue** | Callback Queue (Macrotask) | Microtask Queue |
| **Priority** | Lower | Higher |
| **Control** | Browser controls execution | We control via .then() |

### Promise Object Properties:

- **value** - The result data (auto-filled by browser)
- **status** - 'pending', 'fulfilled', or 'rejected' (auto-updated)
- **onFulfillment** - Array of success handlers (we add via .then)
- **onRejection** - Array of error handlers (we add via .catch)

### Execution Order:

1. Synchronous code (runs first)
2. ALL Microtasks (promises, async/await)
3. ONE Macrotask (setTimeout, setInterval)
4. Repeat

### Microtask Queue Starvation:

- Microtasks can create new microtasks
- If infinite, callback queue never executes
- Event loop prioritizes microtasks completely
- Solution: Break up work or use setTimeout

### Rules for Promise Functions:

1. .then() callbacks go to microtask queue
2. Microtasks execute before macrotasks
3. ALL microtasks run before ONE macrotask
4. Microtasks can create more microtasks (be careful!)
5. Call stack must be empty first
6. Event loop can starve callback queue if microtasks are infinite