# 744\. Find Smallest Letter Greater Than Target (LeetCode)

> Given a sorted array of characters and a target character, find the smallest character in the array that is lexicographically greater than the target. If no such character exists, return the first character in the array. This problem must be solved with $O(\\log n)$ runtime complexity.

-----

## üìù Problem Description

You are given an array of characters `letters` that is sorted in non-decreasing order, and a character `target`. There are at least two different characters in `letters`.

Return the smallest character in `letters` that is lexicographically greater than `target`. If such a character does not exist, return the first character in `letters`.

**Example 1:**

```
Input: letters = ["c","f","j"], target = "a"
Output: "c"
Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
```

**Example 2:**

```
Input: letters = ["c","f","j"], target = "c"
Output: "f"
Explanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.
```

**Example 3:**

```
Input: letters = ["x","x","y","y"], target = "z"
Output: "x"
Explanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].
```

-----

## üí° Approach: Modified Binary Search for Ceiling

This problem can be efficiently solved using a modified binary search algorithm. We are essentially looking for the "ceiling" of the `target` character in the sorted `letters` array, with a wrap-around condition.

The standard binary search template aims to find an exact match or an insertion point. Here, we modify it to find the *first element greater than `target`*.

The key idea is to maintain a `ceilIndex` variable, initialized to 0 (which handles the wrap-around case by default).

  * During the binary search, if `letters[mid]` is less than or equal to `target`, it means `letters[mid]` cannot be our answer (or any element to its left). So, we must search in the right half by setting `start = mid + 1`.
  * If `letters[mid]` is greater than `target`, then `letters[mid]` is a potential candidate for our answer. We record `mid` as `ceilIndex` and try to find an even smaller character that is still greater than `target` by searching in the left half: `end = mid - 1`.

When the `while (start <= end)` loop terminates, `ceilIndex` will hold the index of the smallest character lexicographically greater than `target`. If no such character was found (e.g., `target` is 'z' and all letters are 'x', 'y'), `ceilIndex` will remain its initial value of 0, correctly returning the first character as required by the problem.

-----

## üö∂ Algorithm Steps

1.  Initialize two pointers: `start = 0` and `end = letters.size() - 1`.
2.  Initialize `ceilIndex = 0`. This variable will store the index of the smallest character found so far that is greater than `target`. Setting it to `0` initially naturally handles the wrap-around case (returning `letters[0]`).
3.  Begin a `while` loop that runs as long as `start <= end`.
4.  Inside the loop, calculate the `mid` index: `mid = start + (end - start) / 2`.
5.  Compare `letters[mid]` with `target`:
      * If `letters[mid] <= target`: This means `mid` (and everything to its left) is not the character we're looking for (it's either equal to or smaller than `target`). We need to search in the right half. Update `start = mid + 1`.
      * Else (`letters[mid] > target`): This means `letters[mid]` is a potential answer. We record `mid` as `ceilIndex`. To find an even smaller character that still satisfies the condition, we try to search in the left half. Update `end = mid - 1`.
6.  Once the `while` loop terminates, return `letters[ceilIndex]`.

-----

## üíª Example Walkthrough

Let's trace the algorithm with `letters = ["c","f","j"]`, `target = "c"`

1.  **Initial:** `start = 0`, `end = 2`. `ceilIndex = 0`. `letters = ["c","f","j"]`.

2.  **Iteration 1:**

      * `start <= end` (0 \<= 2) is true.
      * `mid = 0 + (2-0)/2 = 1`. `letters[mid]` (`letters[1]`) is `'f'`.
      * Compare `letters[mid] <= target` ('f' \<= 'c') is `false`.
      * Else block: `letters[mid] > target` ('f' \> 'c') is `true`.
          * `ceilIndex = mid = 1`.
          * `end = mid - 1 = 1 - 1 = 0`.
      * Current state: `start = 0`, `end = 0`. `ceilIndex = 1`.

3.  **Iteration 2:**

      * `start <= end` (0 \<= 0) is true.
      * `mid = 0 + (0-0)/2 = 0`. `letters[mid]` (`letters[0]`) is `'c'`.
      * Compare `letters[mid] <= target` ('c' \<= 'c') is `true`.
      * `start = mid + 1 = 0 + 1 = 1`.
      * Current state: `start = 1`, `end = 0`. `ceilIndex = 1`.

4.  **Loop Termination:**

      * `start <= end` (1 \<= 0) is false. The loop terminates.

5.  **Return:** `letters[ceilIndex]` (i.e., `letters[1]`) which is **'f'**.

The algorithm correctly identified `'f'` as the smallest letter greater than `'c'`.

-----

## üìè Constraints

  * `2 <= letters.length <= 10^4`
  * `letters[i]` is a lowercase English letter.
  * `letters` is sorted in non-decreasing order.
  * `letters` contains at least two different characters.
  * `target` is a lowercase English letter.

-----

## ‚è±Ô∏è Complexity Analysis

  * **Time Complexity**: $O(\\log n)$, where `n` is the length of the `letters` array. This is the inherent time complexity of the binary search algorithm used.
  * **Space Complexity**: $O(1)$, as the algorithm uses a constant amount of auxiliary space for pointers and variables.

-----

## üîë Key Idea

The problem leverages a slightly modified binary search. Instead of searching for an exact match, we are searching for the "ceiling" element ‚Äì the smallest element greater than the target. The crucial part of the modification is how we update our `ceilIndex` and narrow the search space: when a potential candidate greater than the target is found, we store its index and then try to find an even "smaller" candidate in the left half. If `letters[mid]` is less than or equal to `target`, we simply discard the left half and continue searching right. The initialization of `ceilIndex = 0` elegantly handles the wrap-around case where no character greater than `target` exists, causing the first character to be returned.

-----

## üíª Class Implementation

```cpp
#include <vector>

class Solution {
public:
    char nextGreatestLetter(std::vector<char>& letters, char target) {
        int start = 0;
        int end = letters.size() - 1;

        // Initialize ceilIndex to 0. This naturally handles the wrap-around case
        // where no character greater than target is found (e.g., target 'z').
        int ceilIndex = 0; 

        while(start <= end){
            int mid = start + (end - start) / 2; // Safe mid calculation

            if(letters[mid] <= target) {
                // If mid element is less than or equal to target,
                // the answer must be in the right half.
                start = mid + 1;
            } else { 
                // If mid element is greater than target, it's a potential answer.
                // Store its index and try to find an even smaller character in the left half.
                ceilIndex = mid;
                end = mid - 1;
            }
        }
        
        // After the loop, ceilIndex holds the index of the smallest character > target,
        // or 0 if no such character was found (wrap-around).
        return letters[ceilIndex];
    }
};
```

-----

**Last Updated:** August 3, 2025
**Documentation Source:** [LeetCode 744. Find Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/)