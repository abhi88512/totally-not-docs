
-----

# 153\. Find Minimum in Rotated Sorted Array (LeetCode)

> Find the minimum element in a sorted array that has been rotated. The solution must run in $O(\\log n)$ time.

-----

## 📝 Problem Description

Suppose an array of length `n` sorted in ascending order is rotated between 1 and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

  * `[4,5,6,7,0,1,2]` if it was rotated 4 times.
  * `[0,1,2,4,5,6,7]` if it was rotated 7 times.

Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of unique elements, return the minimum element of this array.

You must write an algorithm that runs in $O(\\log n)$ time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

-----

## 💡 Approach: Modified Binary Search

The problem requires an $O(log n)$ solution, which strongly suggests using a binary search approach. The key insight for a rotated sorted array is that the array is essentially split into two sorted parts, and the minimum element is the "pivot" point where the rotation occurs.

Consider the properties of a rotated sorted array:

  * If the array is not rotated (or rotated `n` times), `nums[0]` is the minimum.
  * If rotated, the array will look like `[large_values..., small_values...]`. The minimum element will be the first element of the `small_values` segment.
  * Crucially, if we compare `nums[mid]` with `nums[right]` (or `nums[end]`):
      * **Case 1: `nums[mid] > nums[end]`**: This implies that the middle element `nums[mid]` is part of the "larger values" segment (the left sorted portion). Therefore, the minimum element *must* lie in the right half of the array (from `mid + 1` to `end`).
      * **Case 2: `nums[mid] <= nums[end]`**: This implies that `nums[mid]` is part of the "smaller values" segment (the right sorted portion) or it *is* the minimum element itself. The minimum element *could* be `nums[mid]` or it could be to its left. So, we narrow our search to the left half (from `start` to `mid`). We don't discard `mid` because it could potentially be the minimum.

By consistently applying this logic, the search range will shrink logarithmically until `start` and `end` converge to the index of the minimum element.

-----

## 🚶 Algorithm Steps

1.  Initialize two pointers: `start = 0` and `end = nums.size() - 1`.
2.  Enter a `while` loop that continues as long as `start < end`. This condition ensures there's still a valid range to search within.
3.  Inside the loop, calculate the `mid` index: `mid = start + (end - start) / 2`. This prevents potential integer overflow.
4.  Compare `nums[mid]` with `nums[end]`:
      * If `nums[mid] > nums[end]`: This means `mid` is in the left, larger-valued part of the rotated array. The minimum element must be in the segment `[mid + 1, end]`. So, update `start = mid + 1`.
      * If `nums[mid] <= nums[end]`: This means `mid` is in the right, smaller-valued part of the rotated array, or it's the minimum itself. The minimum element must be in the segment `[start, mid]`. So, update `end = mid`.
5.  When the `while` loop terminates, `start` will be equal to `end`. This single index will point to the minimum element. Return `nums[start]`.

-----

## 💻 Example Walkthrough

Let's trace the algorithm with `nums = [3,4,5,1,2]`

1.  **Initial:** `start = 0`, `end = 4` (`nums.size() - 1`)

      * `nums[start] = 3`, `nums[end] = 2`

2.  **Iteration 1:**

      * `start < end` (0 \< 4) is true.
      * `mid = 0 + (4 - 0) / 2 = 2`.
      * `nums[mid]` (i.e., `nums[2]`) is `5`.
      * `nums[end]` (i.e., `nums[4]`) is `2`.
      * Compare `nums[mid] > nums[end]` (5 \> 2) is `true`.
      * Update `start = mid + 1 = 2 + 1 = 3`.
      * Current state: `start = 3`, `end = 4`.

3.  **Iteration 2:**

      * `start < end` (3 \< 4) is true.
      * `mid = 3 + (4 - 3) / 2 = 3 + 0 = 3`.
      * `nums[mid]` (i.e., `nums[3]`) is `1`.
      * `nums[end]` (i.e., `nums[4]`) is `2`.
      * Compare `nums[mid] > nums[end]` (1 \> 2) is `false`.
      * Update `end = mid = 3`.
      * Current state: `start = 3`, `end = 3`.

4.  **Loop Termination:**

      * `start < end` (3 \< 3) is false. The loop terminates.

5.  **Return:** `nums[start]` (i.e., `nums[3]`) which is **1**.

The algorithm correctly identified `1` as the minimum element.

-----

## 📏 Constraints

  * `n == nums.length`
  * `1 <= n <= 5000`
  * `-5000 <= nums[i] <= 5000`
  * All the integers of `nums` are unique.
  * `nums` is sorted and rotated between 1 and `n` times.

-----

## ⏱️ Complexity Analysis

  * **Time Complexity**: $O(\\log n)$, where `n` is the number of elements in the array. This is due to the binary search approach, which halves the search space in each iteration.
  * **Space Complexity**: $O(1)$, as the algorithm uses a constant amount of extra space for pointers (`start`, `end`, `mid`).

-----

## 🔑 Key Idea

The fundamental idea is to use the property that a rotated sorted array always has a "break point" where the minimum element resides. By strategically comparing the middle element with the rightmost element, we can determine which half of the array contains this minimum element and safely discard the other half, thus achieving logarithmic time complexity. The minimum element is the only one that is smaller than its predecessor (or the first element of the "smaller values" segment).

-----

## 💻 Class Implementation

```cpp
#include <vector> // Required for std::vector

class Solution {
public:
    int findMin(std::vector<int>& nums) {
        int start = 0;
        int end = nums.size() - 1;

        // Loop until start and end pointers converge
        while (start < end) {
            int mid = start + (end - start) / 2; // Calculate mid index safely

            // If nums[mid] is greater than nums[end],
            // it means mid is in the 'left' sorted portion (larger values),
            // so the minimum must be in the right half (including mid+1).
            if (nums[mid] > nums[end]) {
                start = mid + 1;
            } 
            // If nums[mid] is less than or equal to nums[end],
            // it means mid is in the 'right' sorted portion (smaller values),
            // or mid itself is the minimum.
            // So, the minimum must be in the left half (including mid).
            else { 
                end = mid;
            }
        }
        
        // When the loop terminates, start (or end) will point to the minimum element.
        return nums[start]; 
    }
};
```

-----

**Last Updated:** August 2, 2025

**Documentation Source:** [LeetCode 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)