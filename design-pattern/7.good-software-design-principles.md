### Design Principles for Good Software Design

Good software design is flexible, stable, and easy to understand, but its definition and measurement depend on the specific application. Universal principles guide the creation of robust architectures, and many design patterns are built upon these principles. Below are key principles to achieve good design, along with practices to ensure flexibility, stability, and clarity.

#### 1. Encapsulate What Varies
**Principle**: Identify and isolate aspects of the application that are likely to change, separating them from stable components.

**Purpose**: Minimize the impact of changes by containing them within specific modules, reducing the need for extensive rework and testing.

**Example**:
- **Scenario**: In an e-commerce system, the `getOrderTotal` method calculates the total order cost, including taxes, which vary by country (e.g., 7% for the US, 20% for the EU).
- **Before**: Tax logic is mixed with total calculation, making changes cumbersome as tax rules evolve.
  ```pseudo
  method getOrderTotal(order) is
      total = 0
      foreach item in order.lineItems
          total += item.price * item.quantity
      if (order.country == "US")
          total += total * 0.07 // US sales tax
      else if (order.country == "EU")
          total += total * 0.20 // European VAT
      return total
  ```
- **After**: Extract tax logic into a separate `getTaxRate` method, isolating changes to tax rules.
  ```pseudo
  method getOrderTotal(order) is
      total = 0
      foreach item in order.lineItems
          total += item.price * item.quantity
      total += total * getTaxRate(order.country)
      return total

  method getTaxRate(country) is
      if (country == "US")
          return 0.07
      else if (country == "EU")
          return 0.20
      else
          return 0
  ```
- **Class-Level Encapsulation**: If tax logic grows complex, move it to a dedicated `TaxCalculator` class, further isolating it from the `Order` class.

**Benefits**: Changes to tax rules only affect the isolated module, preserving the rest of the system and saving time on implementation and testing.

#### 2. Program to an Interface, Not an Implementation
**Principle**: Depend on abstractions (interfaces or abstract classes) rather than concrete classes to enhance flexibility.

**Purpose**: Enable extensibility without breaking existing code by allowing new implementations to be swapped in seamlessly.

**Example**:
- **Scenario**: A `Company` class in a simulator interacts with employee types (e.g., `Developer`, `Designer`).
- **Before**: The `Company` class directly references concrete employee classes, tightly coupling them.
- **After**:
  1. Identify required methods (e.g., `work()`).
  2. Create an `Employee` interface with these methods.
  3. Have concrete classes (`Developer`, `Designer`) implement the interface.
  4. Make `Company` depend on the `Employee` interface, using polymorphism to handle any employee type.
  5. Declare employee creation as an abstract method in `Company`, allowing subclasses to define specific employee types.

- **Outcome**: The `Company` class becomes independent of specific employee implementations, enabling new company and employee types without altering existing code. This approach aligns with the **Factory Method** pattern.

**Trade-off**: Adds complexity but provides a robust extension point for future functionality.

#### 3. Favor Composition Over Inheritance
**Principle**: Prefer composition (a "has-a" relationship) over inheritance (an "is-a" relationship) to reuse code and avoid inheritance-related issues.

**Purpose**: Composition offers greater flexibility, reduces tight coupling, and avoids problems like inflexible hierarchies or broken encapsulation.

**Problems with Inheritance**:
- Subclasses must implement all abstract methods of the superclass, even if unused.
- Overriding methods must maintain compatibility with the superclass to avoid breaking code expecting superclass behavior.
- Inheritance exposes superclass internals to subclasses, breaking encapsulation.
- Changes in superclasses can break subclasses due to tight coupling.
- Multi-dimensional inheritance (e.g., combining vehicle type, engine type, and navigation type) leads to a combinatorial explosion of subclasses.

**Example**:
- **Scenario**: A car manufacturerâ€™s catalog app needs classes for cars and trucks, with variations in engine type (electric/gas) and navigation (manual/autopilot).
- **Inheritance Approach**: Creating subclasses for each combination (e.g., `ElectricManualCar`, `GasAutopilotTruck`) results in many classes with duplicated code, as a class cannot inherit from multiple parents.
- **Composition Approach**: Extract behaviors (e.g., engine, navigation) into separate classes. A `Car` object delegates behavior to `Engine` and `Navigation` objects.
  - **Before (Inheritance)**: Subclasses multiply with each new dimension, leading to code duplication.
  - **After (Composition)**: Independent class hierarchies for each behavior (e.g., `ElectricEngine`, `AutopilotNavigation`) allow a `Car` to compose behaviors dynamically, even at runtime.

**Benefits**:
- Avoids bloated class hierarchies.
- Enables runtime behavior changes (e.g., swapping an engine).
- Aligns with the **Strategy** pattern for flexible behavior delegation.

#### Measuring Good Design
Good design can be assessed by:
- **Flexibility**: Can the system be extended without modifying existing code (e.g., adding new employee types or tax rules)?
- **Stability**: Does a change in one module affect unrelated parts of the system?
- **Understandability**: Is the code structure clear, with responsibilities well-separated and intuitive?
- **Reusability**: Can components be used in new contexts with minimal rework?

#### Practices to Achieve Good Design
1. **Apply Encapsulation**: Isolate variable components (e.g., tax calculations) into separate methods or classes to limit change impact.
2. **Use Abstractions**: Design to interfaces or abstract classes to decouple components and support polymorphism.
3. **Prefer Composition**: Structure systems with "has-a" relationships to avoid inheritance pitfalls and enable dynamic behavior.
4. **Leverage Design Patterns**: Use patterns like Factory Method or Strategy, which embody these principles, to guide implementation.
5. **Anticipate Change**: Design with future extensions in mind, such as new features or platform support, by keeping components loosely coupled.
6. **Refactor Regularly**: Simplify overgrown methods or classes by extracting responsibilities, as shown in the tax calculation example.

By following these principles and practices, you create architectures that are easier to extend, maintain, and understand, aligning with the goals of robust software design.