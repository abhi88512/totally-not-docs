# The Clean Architecture

**Author:** Robert C. Martin (Uncle Bob)
**Date:** 13 August 2012

-----

![alt text](the-clean-archetecture.png)

A good software architectures produce systems that are:

  * Independent of Frameworks. The architecture does not depend on the existence of some library of feature laden software. This allows you to use such frameworks as tools, rather than having to cram your system into their limited constraints.
  * Testable. The business rules can be tested without the UI, Database, Web Server, or any other external element.
  * Independent of UI. The UI can change easily, without changing the rest of the system. A Web UI could be replaced with a console UI, for example, without changing the business rules.
  * Independent of Database. You can swap out Oracle or SQL Server, for Mongo, BigTable, CouchDB, or something else. Your business rules are not bound to the database.
  * Independent of any external agency. In fact your business rules simply don’t know anything at all about the outside world.

The diagram at the top of this article is an attempt at integrating all these architectures into a single actionable idea.

## The Dependency Rule

The concentric circles represent different areas of software. In general, the further in you go, the higher level the software becomes. The outer circles are mechanisms. The inner circles are policies.

The overriding rule that makes this architecture work is **The Dependency Rule**.

> This rule says that **source code dependencies** can only point **inwards**. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.

By the same token, data formats used in an outer circle should not be used by an inner circle, especially if those formats are generated by a framework in an outer circle. We don’t want anything in an outer circle to impact the inner circles.

## Entities

Entities encapsulate **Enterprise wide** business rules. An entity can be an object with methods, or it can be a set of data structures and functions. It doesn’t matter so long as the entities could be used by many different applications in the enterprise.

If you don’t have an enterprise, and are just writing a single application, then these entities are the business objects of the application. They encapsulate the most general and high-level rules. They are the least likely to change when something external changes. For example, you would not expect these objects to be affected by a change to page navigation, or security. No operational change to any particular application should affect the entity layer.

## Use Cases

The software in this layer contains **application specific** business rules. It encapsulates and implements all of the use cases of the system. These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their **enterprise wide** business rules to achieve the goals of the use case.

We do not expect changes in this layer to affect the entities. We also do not expect this layer to be affected by changes to externalities such as the database, the UI, or any of the common frameworks. This layer is isolated from such concerns.

We **do**, however, expect that changes to the operation of the application **will** affect the use-cases and therefore the software in this layer. If the details of a use-case change, then some code in this layer will certainly be affected.

## Interface Adapters

The software in this layer is a set of adapters that convert data from the format most convenient for the use cases and entities, to the format most convenient for some external agency such as the Database or the Web. It is this layer, for example, that will wholly contain the MVC architecture of a GUI. The Presenters, Views, and Controllers all belong in here. The models are likely just data structures that are passed from the controllers to the use cases, and then back from the use cases to the presenters and views.

Similarly, data is converted, in this layer, from the form most convenient for entities and use cases, into the form most convenient for whatever persistence framework is being used. i.e. The Database. No code inward of this circle should know anything at all about the database. If the database is a SQL database, then all the SQL should be restricted to this layer, and in particular to the parts of this layer that have to do with the database.

Also in this layer is any other adapter necessary to convert data from some external form, such as an external service, to the internal form used by the use cases and entities.

## Frameworks and Drivers.

The outermost layer is generally composed of frameworks and tools such as the Database, the Web Framework, etc. Generally you don’t write much code in this layer other than glue code that communicates to the next circle inwards.

This layer is where all the details go. The Web is a detail. The database is a detail. We keep these things on the outside where they can do little harm.

## Only Four Circles?

No, the circles are schematic. You may find that you need more than just these four. There’s no rule that says you must always have just these four. However, **The Dependency Rule** always applies. Source code dependencies always point inwards. As you move inwards the level of abstraction increases. The outermost circle is low level concrete detail. As you move inwards the software grows more abstract, and encapsulates higher level policies. The inner most circle is the most general.

## Crossing boundaries.

At the lower right of the diagram is an example of how we cross the circle boundaries. It shows the Controllers and Presenters communicating with the Use Cases in the next layer. Note the flow of control. It begins in the controller, moves through the use case, and then winds up executing in the presenter. Note also the source code dependencies. Each one of them points inwards towards the use cases.

We usually resolve this apparent contradiction by using the **Dependency Inversion Principle**. In a language like Java, for example, we would arrange interfaces and inheritance relationships such that the source code dependencies oppose the flow of control at just the right points across the boundary.

For example, consider that the use case needs to call the presenter. However, this call must not be direct because that would violate **The Dependency Rule**: No name in an outer circle can be mentioned by an inner circle. So we have the use case call an interface (Shown here as Use Case Output Port) in the inner circle, and have the presenter in the outer circle implement it.

The same technique is used to cross all the boundaries in the architectures. We take advantage of dynamic polymorphism to create source code dependencies that oppose the flow of control so that we can conform to **The Dependency Rule** no matter what direction the flow of control is going in.

## What data crosses the boundaries.

Typically the data that crosses the boundaries is simple data structures. You can use basic structs or simple Data Transfer objects if you like. Or the data can simply be arguments in function calls. Or you can pack it into a hashmap, or construct it into an object. The important thing is that isolated, simple, data structures are passed across the boundaries. We don’t want to cheat and pass **Entities** or Database rows. We don’t want the data structures to have any kind of dependency that violates **The Dependency Rule**.

For example, many database frameworks return a convenient data format in response to a query. We might call this a RowStructure. We don’t want to pass that row structure inwards across a boundary. That would violate **The Dependency Rule** because it would force an inner circle to know something about an outer circle.

So when we pass data across a boundary, it is always in the form that is most convenient for the inner circle.

## Conclusion

Conforming to these simple rules is not hard, and will save you a lot of headaches going forward. By separating the software into layers, and conforming to **The Dependency Rule**, you will create a system that is intrinsically testable, with all the benefits that implies. When any of the external parts of the system become obsolete, like the database, or the web framework, you can replace those obsolete elements with a minimum of fuss.

## Integrating Common Patterns and Concepts

This section explains how common architectural components and patterns fit within the concentric layers of Clean Architecture, adhering to The Dependency Rule.

### Repository, Service, Controller, Interface, Entities, DTO, Model

  * **Entities / Domain Models**: These reside in the **Entities** layer (innermost circle). They encapsulate enterprise-wide business rules and are framework-independent. A `Model` (when referring to the core domain model or business objects) directly maps to this layer.
  * **Use Cases / Application Services**: The **Use Cases** layer is where `Service` layer components (specifically, *Application Services* or *Interactors*) typically live. They implement application-specific business rules, orchestrate entities, and coordinate data flow for specific use cases. They are isolated from UI and database concerns.
  * **Controllers**: Controllers are located within the **Interface Adapters** layer. Controllers (e.g., from an MVC web framework) translate external inputs (like HTTP requests or GUI events) into a format suitable for the Use Cases layer. They interact with Use Cases, which in turn operate on Entities.
  * **Interfaces (Ports)**: Interfaces are crucial for maintaining The Dependency Rule and implementing the Dependency Inversion Principle. They act as "Ports." Interfaces (e.g., `IRepository`, `IOutputPort`) are defined in **inner circles** (often within Use Cases or Entities, as abstracts). Their concrete *implementations* reside in **outer circles** (e.g., a `SqlUserRepository` implementation in the Frameworks and Drivers layer, or a `WebPresenter` implementation in the Interface Adapters layer). This ensures inner layers depend only on abstractions.
  * **Repositories (Implementation / Adapters)**: The *interface* for a Repository (e.g., `UserRepositoryInterface`) is defined in an inner layer (often Use Cases, as the use case needs data access). The concrete *implementation* of this interface (e.g., `SqlUserRepository`, `MongoUserRepository`) resides in the **Interface Adapters** or **Frameworks and Drivers** layer, where database details are handled. This setup allows inner layers to depend on the abstract contract, while outer layers provide the concrete details.
  * **DTOs (Data Transfer Objects)**: DTOs are simple data structures used specifically to cross architectural boundaries. They are typically defined and used in the **Interface Adapters** layer. DTOs convert data from the Use Case/Entity format to an external format (for UI/API) or vice versa. They are strictly data carriers and must not contain business logic or carry dependencies that violate The Dependency Rule (e.g., no framework-specific ORM objects should be passed inwards as DTOs).
  * **Model (Presentation Model)**: In the context of MVC within the **Interface Adapters** layer, "Model" can also refer to a Presentation Model or View Model. This is a data structure prepared specifically for the UI/View to consume. It is distinct from the core "Domain Model" or "Entities" found in the innermost layer.

### CQRS (Command Query Responsibility Segregation)

CQRS (Command Query Responsibility Segregation) aligns well with Clean Architecture's separation of concerns, particularly by leveraging the distinct responsibilities of the Use Cases and Interface Adapters layers for different data flows.

  * **Commands (Write Operations)**:
      * Commands (requests to change state) typically enter the system through a `Controller` in the **Interface Adapters** layer.
      * The `Controller` translates the external command into a suitable input for a specific command-handling method within the `Use Cases` layer.
      * The `Use Cases` layer processes this command by orchestrating `Entities` and interacting with `Repository Interfaces` (defined in Use Cases, implemented in Frameworks/Drivers) to persist changes to the write model database.
      * This flow strictly follows The Dependency Rule: `Controller` (outer) calls `Use Case` (inner), `Use Case` (inner) calls `Repository Interface` (inner abstraction), and the concrete `Repository Implementation` (outer) implements the `Repository Interface`.
  * **Queries (Read Operations)**:
      * Queries (requests for data without changing state) also typically enter through a `Controller` in the **Interface Adapters** layer.
      * For optimization, queries often bypass the core `Use Cases` and `Entities` layers. Instead, the `Controller` might directly call a dedicated **Query Service** (also in **Interface Adapters**).
      * This `Query Service` or read adapter directly accesses a read-optimized data store (which resides in the **Frameworks and Drivers** layer).
      * The results are typically returned as `DTOs` to the `Controller` for presentation, without involving the complex domain logic of the Entities.
      * This direct read path avoids the overhead of the full domain model, while still adhering to The Dependency Rule as queries flow from outer layers to outer data layers.

### CQRS with React Client and .NET Web API Example

Here's how typical components in a React client and .NET Web API stack, applying CQRS, fit into Clean Architecture:

  * **React Client**: This forms the primary **Frameworks and Drivers** layer on the client-side. It's the outermost detail, handling UI presentation and user interaction. It dispatches commands (via HTTP requests) and fetches data (via HTTP requests for queries) from the API.
  * **API (ASP.NET Core Web API)**: The Web API itself, including its framework-specific controllers, belongs to the **Frameworks and Drivers** layer on the server-side. Its controllers act as the primary entry point, receiving HTTP requests and translating them.
      * **API Controllers (within Web API)**: Reside conceptually in the **Interface Adapters** layer. They receive HTTP requests (Commands or Queries) and adapt them into suitable inputs for the Application Layer (Use Cases or Query Services). They also adapt outputs from the Application Layer back into HTTP responses (often using DTOs).
  * **Application Layer (e.g., .NET Application Services)**: This maps directly to the **Use Cases** layer. It contains the application-specific business logic and orchestrates domain entities and persistence operations.
      * **Command Handlers**: Within the Application Layer, these receive commands (e.g., `CreateOrderCommand`) from the API controllers. They encapsulate the specific business rules for that command, interact with the Domain Layer, and use Persistence Layer interfaces to save changes.
      * **Query Handlers**: Also within the Application Layer, these receive queries (e.g., `GetProductByIdQuery`). For complex queries, they might orchestrate domain logic; for read-optimized queries (common in CQRS), they might directly interact with read-specific interfaces from the Persistence Layer.
  * **Domain Layer (e.g., .NET Domain Models, Entities, Value Objects)**: This maps directly to the **Entities** layer (innermost circle). It contains the core enterprise-wide business rules, entities, and value objects that are completely independent of any frameworks or external concerns. The Application Layer operates on these domain objects.
  * **Persistence Layer (e.g., Entity Framework Core, Dapper implementations)**: This layer's concrete implementations reside in the **Frameworks and Drivers** layer. This is where actual database interactions occur (e.g., SQL queries, ORM mapping).
      * **Persistence Interfaces**: Interfaces like `IRepository<T>` (for write models) or `IReadModelRepository<T>` (for read models) are defined in the **Domain Layer** or **Application Layer** (closer to the core), following the Dependency Inversion Principle. The concrete `DbContext` or Dapper implementations in the Persistence Layer implement these interfaces. This allows the inner layers to remain unaware of the database technology.

This layered structure ensures that the core business logic in the Domain and Application layers remains clean, testable, and independent of UI (React Client), API framework (.NET Web API), and database details.

-----

**Original Source:** [The Clean Code Blog - The Clean Architecture](https://www.google.com/search?q=http://blog.cleancoder.com/2012/08/13/the-clean-architecture.html)

**Last Updated:** August 3, 2025