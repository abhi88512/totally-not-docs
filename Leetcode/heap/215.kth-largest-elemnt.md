# 215\. Kth Largest Element in an Array (LeetCode)

> Given an integer array `nums` and an integer `k`, return the k-th largest element in the array. This is the k-th largest element in sorted order, not the k-th distinct element. Can you solve it without sorting in $O(N \\log K)$ time complexity?

-----

## üìù Problem Description

Given an integer array `nums` and an integer `k`, return the k-th largest element in the array.

Note that it is the k-th largest element in the sorted order, not the k-th distinct element.

Can you solve it without sorting?

**Example 1:**

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```

**Example 2:**

```
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

-----

## üí° Approach: Min-Heap of Size K

This problem is a classic application of a heap, specifically a min-heap of a fixed size `k`. The goal is to efficiently find the k-th largest element without performing a full sort of the entire array, which would have a higher time complexity of $O(N \log N)$.

The approach is to maintain a min-heap that stores the `k` largest elements encountered so far. A min-heap is used because its smallest element is always at the top.

The logic is as follows:

  * Iterate through the `nums` array one element at a time.
  * For each element, push it into the min-heap.
  * After each push, if the size of the min-heap exceeds `k`, pop the top element. Since it is a min-heap, the element at the top is the smallest among the elements currently in the heap.
  * By doing this, we ensure the heap always contains the `k` largest elements we have seen so far. The smallest of these `k` largest elements is the one that is at the top of the min-heap.

After iterating through the entire array, the element at the top of the min-heap will be the k-th largest element in the complete array.

-----

## üö∂ Algorithm Steps

1.  Create a min-heap (e.g., `std::priority_queue` with `std::greater`).
2.  Iterate through each `num` in the input array `nums`.
3.  Push `num` onto the min-heap.
4.  If the size of the min-heap becomes greater than `k`, pop the top element from the heap.
5.  After the loop completes, return the top element of the min-heap.

-----

## üíª Example Walkthrough

Let's trace the algorithm with `nums = [3,2,1,5,6,4]` and `k = 2`.

1.  Create an empty min-heap `minH`. `k = 2`.
2.  **`num = 3`**: `minH.push(3)`. `minH` size is 1. `[3]`
3.  **`num = 2`**: `minH.push(2)`. `minH` size is 2. `[2, 3]`
4.  **`num = 1`**: `minH.push(1)`. `minH` size is 3. `[1, 2, 3]`. `minH` size is \> `k`, so `minH.pop()`. `minH` becomes `[2, 3]`.
5.  **`num = 5`**: `minH.push(5)`. `minH` size is 3. `[2, 3, 5]`. `minH` size is \> `k`, so `minH.pop()`. `minH` becomes `[3, 5]`.
6.  **`num = 6`**: `minH.push(6)`. `minH` size is 3. `[3, 5, 6]`. `minH` size is \> `k`, so `minH.pop()`. `minH` becomes `[5, 6]`.
7.  **`num = 4`**: `minH.push(4)`. `minH` size is 3. `[4, 5, 6]`. `minH` size is \> `k`, so `minH.pop()`. `minH` becomes `[5, 6]`.
8.  Loop finishes. Return `minH.top()`, which is `5`.

The 2nd largest element is indeed 5.

-----

## üìè Constraints

  * `1 <= k <= nums.length <= 10^5`
  * `-10^4 <= nums[i] <= 10^4`

-----

## ‚è±Ô∏è Complexity Analysis

  * **Time Complexity**: $O(N \log K)$, where `N` is the number of elements in `nums`. For each of the `N` elements, we perform a heap `push` or `pop` operation. These operations on a heap of size `K` take $O(\log K)$ time.
  * **Space Complexity**: $O(K)$, as the min-heap stores at most `K` elements.

-----

## üîë Key Idea

The core idea is to leverage a min-heap to keep track of the `k` largest elements seen so far. A min-heap is chosen because the smallest element is at the top. By keeping the heap size capped at `k`, we ensure that any new element larger than the smallest of our `k` candidates will be retained, while the smallest candidate is discarded. The final element at the top of the heap is the k-th largest element overall.

-----

## üíª Class Implementation

```cpp
#include <vector>
#include <queue>
#include <functional> // Required for std::greater

class Solution {
public:
    int findKthLargest(std::vector<int>& nums, int k) {
        // Create a min-heap (std::priority_queue with std::greater)
        std::priority_queue<int, std::vector<int>, std::greater<int>> minH;

        for (int i = 0; i < nums.size(); ++i) {
            minH.push(nums[i]);

            // If the heap size exceeds k, pop the smallest element
            if (minH.size() > k) {
                minH.pop();
            }
        }
        
        // The top of the min-heap is the kth largest element
        return minH.top();
    }
};
```

-----

**Last Updated:** August 5, 2025

**Documentation Source:** [LeetCode 215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)