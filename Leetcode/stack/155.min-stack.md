## üìÑ Updated/New Document

```markdown
# 155. Min Stack (LeetCode)

> Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

## üìã Table of Contents
- [Problem Description](#-problem-description)
- [Approach: Two Stacks](#approach-two-stacks)
- [Example Walkthrough](#example-walkthrough)
- [Constraints](#constraints)
- [Complexity Analysis](#-complexity-analysis)
- [Key Idea](#-key-idea)
- [Class Implementation](#class-implementation)
- [See Also](#-see-also)

---

## üìù Problem Description
Implement the MinStack class:

* `MinStack()` initializes the stack object.
* `void push(int val)` pushes the element `val` onto the stack.
* `void pop()` removes the element on the top of the stack.
* `int top()` gets the top element of the stack.
* `int getMin()` retrieves the minimum element in the stack.

You must implement a solution with $O(1)$ time complexity for each function.

**Example 1:**
```

Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

````
**Explanation**
```cpp
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
````

-----

## üí° Approach: Two Stacks

The core idea for achieving $O(1)$ time complexity for all `MinStack` operations, including `getMin`, involves using **two stacks**:

1.  **`mainStack`**: This stack behaves exactly like a regular stack. All elements pushed onto `MinStack` are stored here.
2.  **`minStack`**: This auxiliary stack is responsible for tracking the minimum element encountered *up to each corresponding point* in the `mainStack`. It maintains elements in non-increasing order from bottom to top.

Here's how operations work with this approach:

  * **`push(int val)`**:

      * Always push `val` onto the `mainStack`.
      * For `minStack`: If `minStack` is currently empty, or if `val` is less than or equal to the element at the top of `minStack` (`minStack.top()`), then push `val` onto `minStack`. The "less than or equal to" condition is crucial. It ensures that if there are duplicate minimum values, both instances are tracked, preventing `getMin` from returning an incorrect value after a minimum is popped.

  * **`pop()`**:

      * Before popping from `mainStack`, you need to check if the element at `mainStack.top()` is equal to `minStack.top()`.
      * If they are equal, it signifies that the element being removed from `mainStack` is the current minimum. In this case, also pop from `minStack` to keep its state consistent with `mainStack`.
      * Finally, always pop from `mainStack`.

  * **`top()`**:

      * Simply return `mainStack.top()`. This is an $O(1)$ operation.

  * **`getMin()`**:

      * Simply return `minStack.top()`. This is also an $O(1)$ operation, as `minStack` is designed to always have the current minimum at its top.

-----

## üö∂ Example Walkthrough

Let's trace the execution of the given example to illustrate the two-stack approach:

**Input:**
`["MinStack","push","push","push","getMin","pop","top","getMin"]`
`[[],[-2],[0],[-3],[],[],[],[]]`

**Step-by-Step Breakdown:**

1.  `MinStack minStack = new MinStack();`

      * `mainStack`: `[]` (empty)
      * `minStack`: `[]` (empty)

2.  `minStack.push(-2);`

      * `mainStack.push(-2)` ‚Üí `mainStack`: `[-2]`
      * `minStack.empty()` is true, so `minStack.push(-2)` ‚Üí `minStack`: `[-2]`

3.  `minStack.push(0);`

      * `mainStack.push(0)` ‚Üí `mainStack`: `[-2, 0]`
      * `minStack.empty()` is false. `0 <= minStack.top()` (0 \<= -2) is `false`. `minStack` remains `[-2]`.

4.  `minStack.push(-3);`

      * `mainStack.push(-3)` ‚Üí `mainStack`: `[-2, 0, -3]`
      * `minStack.empty()` is false. `-3 <= minStack.top()` (-3 \<= -2) is `true`. `minStack.push(-3)` ‚Üí `minStack`: `[-2, -3]`

5.  `minStack.getMin();`

      * Returns `minStack.top()`, which is **-3**.

6.  `minStack.pop();`

      * `mainStack.top()` is `-3`. `minStack.top()` is `-3`. They are equal.
      * `minStack.pop()` ‚Üí `minStack`: `[-2]`
      * `mainStack.pop()` ‚Üí `mainStack`: `[-2, 0]`

7.  `minStack.top();`

      * Returns `mainStack.top()`, which is **0**.

8.  `minStack.getMin();`

      * Returns `minStack.top()`, which is **-2**.

**Output:** `[null,null,null,null,-3,null,0,-2]` (This matches the expected output from the problem).

-----

## üìè Constraints

  * $-2^{31} \\le \\text{val} \\le 2^{31} - 1$ (This covers the range of a standard 32-bit signed integer).
  * Methods `pop`, `top`, and `getMin` operations will always be called on non-empty stacks. (This simplifies the implementation by removing the need for explicit `empty()` checks within these methods before accessing elements, though it's still a good general practice).
  * At most $3 \\times 10^4$ calls will be made to `push`, `pop`, `top`, and `getMin`.

-----

## ‚è±Ô∏è Complexity Analysis

  * **Time Complexity**: $O(1)$ for all operations (`push`, `pop`, `top`, `getMin`).
      * Each operation on `MinStack` involves a constant number of fundamental `std::stack` operations (like `push`, `pop`, `top`, `empty`). Since `std::stack` operations themselves are $O(1)$ (or amortized $O(1)$ if using `std::vector` as the underlying container), the overall time complexity remains constant.
  * **Space Complexity**: $O(N)$, where $N$ is the number of elements currently in the `MinStack`.
      * In the worst-case scenario (e.g., when elements are pushed in strictly decreasing order like 5, 4, 3, 2, 1), both `mainStack` and `minStack` will grow to store $N$ elements. Thus, the total space used by the two stacks is proportional to $2N$, which simplifies to $O(N)$.

-----

## üîë Key Idea

The fundamental insight behind this solution is not to simply store a single global minimum, but rather to **maintain the minimum element *at each corresponding level* of the main stack**. By using `minStack.top()` to always reflect the true minimum of all elements *currently residing in `mainStack`*, we enable $O(1)$ retrieval. The careful handling of equal values during `push` and `pop` ensures correctness, especially when multiple instances of the minimum value are present.

-----

## üíª Class Implementation

```cpp
#include <stack> // Required for std::stack

class MinStack {
private:
    std::stack<int> mainStack; // Stores all elements pushed onto the stack
    std::stack<int> minStack;  // Stores minimums encountered so far

public:
    // Constructor: Initializes the stack objects. std::stack's default constructor handles this.
    MinStack() {
        // No explicit initialization code needed here.
    }
    
    // Pushes the element val onto the stack.
    void push(int val) {
        mainStack.push(val); // Always push to the main stack

        // Push 'val' onto minStack only if it's the new minimum
        // (or equal to the current minimum, important for duplicates).
        if (minStack.empty() || val <= minStack.top()) {
            minStack.push(val);
        }
    }
    
    // Removes the element on the top of the stack.
    void pop() {
        // Check if the element being popped from mainStack is the current minimum.
        // If it is, then it must also be removed from minStack.
        if (mainStack.top() == minStack.top()) {
            minStack.pop();
        }
        mainStack.pop(); // Always pop from the main stack
    }
    
    // Gets the top element of the stack.
    int top() {
        // Per constraints, this will always be called on a non-empty stack.
        return mainStack.top();
    }
    
    // Retrieves the minimum element in the stack.
    int getMin() {
        // Per constraints, this will always be called on a non-empty stack.
        return minStack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

-----

## üîó See Also

  - [suspicious link removed]
  - [suspicious link removed]

-----

**Last Updated:** 2025-08-02
**Documentation Source:** [LeetCode 155. Min Stack](https://leetcode.com/problems/min-stack/description/)

-----
