# Redux Interview Questions in React

## Question 1: What is Redux?
Redux is a state management library often used with React. It helps in managing the application state in a predictable way by centralizing the state in a single store, enabling easy debugging and testing.

### Key Concepts:
- **Single source of truth** - All state in one store
- **State is read-only** - Only changed through actions
- **Changes made with pure functions** - Reducers are pure functions

```

---

## Question 2: How does the Redux state management work?

### Redux Flow (Unidirectional Data Flow):
1. **Component dispatches an Action**
2. **Action goes to Reducer**
3. **Reducer updates Store**
4. **Store notifies Components**
5. **Components re-render with new state**

### Visual Flow:
```
Component → dispatch(action) → Reducer → Store → Component
```

### Complete Example:
```jsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  // 1. Get state from store
  const count = useSelector(state => state.count);
  
  // 2. Get dispatch function
  const dispatch = useDispatch();

  // 3. Dispatch actions
  const increment = () => dispatch({ type: 'INCREMENT' });
  const decrement = () => dispatch({ type: 'DECREMENT' });

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

---

## Question 3: How do you define an action in Redux?

### Action Structure:
```jsx
// Simple action
const incrementAction = {
  type: 'INCREMENT',
  payload: 'data'
};

// Action with payload
const addTodoAction = {
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux',
    completed: false
  }
};
```

### Action Creators (Recommended):
```jsx
// Action creators - functions that return actions
const increment = () => ({
  type: 'INCREMENT'
});

const decrement = () => ({
  type: 'DECREMENT'
});

const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: {
    id: Date.now(),
    text,
    completed: false
  }
});

// Usage
dispatch(increment());
dispatch(addTodo('Learn Redux'));
```

### Action Types Constants:
```jsx
// Define action types as constants to avoid typos
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';
const ADD_TODO = 'ADD_TODO';

const increment = () => ({ type: INCREMENT });
const decrement = () => ({ type: DECREMENT });
```

---

## Question 4: What is a reducer in Redux? Show an example.

A **reducer** is a pure function that takes the current state and an action, and returns a new state. It specifies how the state changes in response to actions.

### Simple Counter Reducer:
```jsx
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'RESET':
      return 0;
    default:
      return state;
  }
};
```

### Todo List Reducer:
```jsx
const todosReducer = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.payload.id);
    
    default:
      return state;
  }
};
```

### Complex State Reducer:
```jsx
const initialState = {
  count: 0,
  user: null,
  loading: false
};

const appReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + 1
      };
    
    case 'SET_USER':
      return {
        ...state,
        user: action.payload
      };
    
    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload
      };
    
    default:
      return state;
  }
};
```

---

## Question 5: How do you create a Redux store?

### Simple Store Creation:
```jsx
import { createStore } from 'redux';

// Create store with reducer
const store = createStore(counterReducer);

// Get current state
console.log(store.getState());

// Subscribe to changes
store.subscribe(() => {
  console.log('State changed:', store.getState());
});

// Dispatch action
store.dispatch({ type: 'INCREMENT' });
```

### Store with Multiple Reducers:
```jsx
import { createStore, combineReducers } from 'redux';

// Combine multiple reducers
const rootReducer = combineReducers({
  counter: counterReducer,
  todos: todosReducer,
  user: userReducer
});

const store = createStore(rootReducer);

// State structure will be:
// {
//   counter: 0,
//   todos: [],
//   user: null
// }
```

### Store with Middleware:
```jsx
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
  rootReducer,
  applyMiddleware(thunk)
);
```

### Modern Redux Toolkit (Recommended):
```jsx
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
  reducer: {
    counter: counterReducer,
    todos: todosReducer
  }
});
```

---

## Question 6: What is redux-thunk middleware in Redux and how do you apply it?

**Redux Thunk** is middleware that allows you to write action creators that return functions instead of plain action objects. This enables handling asynchronous operations like API calls.

### Without Thunk (Synchronous):
```jsx
// Regular action creator
const increment = () => ({
  type: 'INCREMENT'
});

// Dispatch
dispatch(increment());
```

### With Thunk (Asynchronous):
```jsx
// Thunk action creator - returns a function
const fetchUser = (userId) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    try {
      const response = await fetch(`/api/users/${userId}`);
      const user = await response.json();
      
      dispatch({
        type: 'FETCH_USER_SUCCESS',
        payload: user
      });
    } catch (error) {
      dispatch({
        type: 'FETCH_USER_ERROR',
        payload: error.message
      });
    }
  };
};

// Usage
dispatch(fetchUser(123));
```

### Setting up Thunk:
```jsx
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
  rootReducer,
  applyMiddleware(thunk)
);
```

### Complete Async Example:
```jsx
// Action creators
const setLoading = (loading) => ({
  type: 'SET_LOADING',
  payload: loading
});

const setTodos = (todos) => ({
  type: 'SET_TODOS',
  payload: todos
});

const setError = (error) => ({
  type: 'SET_ERROR',
  payload: error
});

// Thunk action creator
const fetchTodos = () => {
  return async (dispatch) => {
    dispatch(setLoading(true));
    
    try {
      const response = await fetch('/api/todos');
      const todos = await response.json();
      dispatch(setTodos(todos));
    } catch (error) {
      dispatch(setError(error.message));
    } finally {
      dispatch(setLoading(false));
    }
  };
};

// Component usage
function TodoList() {
  const { todos, loading } = useSelector(state => state);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);

  if (loading) return <div>Loading...</div>;

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

---

## Question 7: When would you choose Context API over Redux, and vice versa?

### Choose Context API when:
- **Small to medium apps** with simple state management needs
- **Theme or user preferences** that don't change frequently
- **Authentication state** (login/logout)
- **Avoiding prop drilling** for a few components
- **Simple state logic** without complex updates

### Context API Example:
```jsx
const UserContext = createContext();

function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

function Profile() {
  const { user } = useContext(UserContext);
  return <div>Welcome {user?.name}</div>;
}
```

### Choose Redux when:
- **Complex state logic** with multiple actions and state updates
- **Large applications** with many components sharing state
- **Time travel debugging** needed (Redux DevTools)
- **Predictable state updates** with strict patterns required
- **Middleware needed** for async operations, logging, etc.

### Redux Example:
```jsx
// Multiple reducers, complex state, middleware
const store = configureStore({
  reducer: {
    user: userReducer,
    posts: postsReducer,
    comments: commentsReducer,
    notifications: notificationsReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(thunk, logger)
});
```

### Comparison Table:

| Feature | Context API | Redux |
|---------|-------------|-------|
| **Learning Curve** | Easy | Moderate |
| **Boilerplate** | Minimal | More |
| **Performance** | Can cause re-renders | Optimized |
| **DevTools** | Basic | Excellent |
| **Middleware** | No | Yes |
| **Time Travel** | No | Yes |
| **Community** | Smaller | Large |
| **Best For** | Simple state | Complex state |

### Hybrid Approach:
You can use both together:
```jsx
// Context for simple state (theme, user)
const ThemeContext = createContext();

// Redux for complex state (data, business logic)
const store = configureStore({
  reducer: {
    posts: postsReducer,
    comments: commentsReducer
  }
});

function App() {
  return (
    <Provider store={store}>
      <ThemeProvider>
        <AppContent />
      </ThemeProvider>
    </Provider>
  );
}
```

---

## Key Interview Points:

### Redux Benefits:
- **Predictable state management** with clear data flow
- **Centralized state** in single store
- **Time travel debugging** with Redux DevTools
- **Middleware support** for async operations
- **Large community** and ecosystem

### Redux Core Principles:
1. **Single source of truth** - One store for entire app
2. **State is read-only** - Only changed through actions
3. **Changes with pure functions** - Reducers are pure functions

### When to Use Redux:
- Complex state logic
- Multiple components need same state
- Need debugging tools
- Team wants strict patterns
- Large applications