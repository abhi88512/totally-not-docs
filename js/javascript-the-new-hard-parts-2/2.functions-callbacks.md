# Higher Order Functions in JavaScript - Complete Guide

## Why Use Functions?

### 1. DRY Principle (Don't Repeat Yourself)
- Write code once, use it many times
- Run less code = better performance
- Easier to maintain and debug

### 2. Reusability
- Same function can be used in different parts of your program
- Save time and effort

### 3. Generalization with Parameters
- Make functions flexible by using parameters
- Data is **TBD (To Be Determined)** until we run the function

---

## The Problem: Repetitive Code

### Example 1: Multiply by 2
```javascript
function copyArrayAndMultiply2(array) {
    const output = [];
    for (let i = 0; i < array.length; i++) {
        output.push(array[i] * 2);
    }
    return output;
}

const myArray = [1, 2, 3];
const result = copyArrayAndMultiply2(myArray);
```

### Execution Steps:

#### Step 1-2: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  MEMORY                                ║
║                                        ║
║  copyArrayAndMultiply2: f{} (function) ║
║  myArray: [1, 2, 3]                    ║
║  result: ???                           ║
║                                        ║
╚════════════════════════════════════════╝
```

#### Step 3-4: Function Called
```
CALL STACK:
┌─────────────────────────────────┐
│ copyArrayAndMultiply2([1,2,3])  │ ← EXECUTING
├─────────────────────────────────┤
│ Global Context (PAUSED)         │
└─────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  copyArrayAndMultiply2([1,2,3])        ║
        ╠════════════════════════════════════════╣
        ║  array: [1, 2, 3]                      ║
        ║  output: []                            ║
        ║  i: 0                                  ║
        ╚════════════════════════════════════════╝
```

#### Step 5-6: Loop Execution
```
        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ╠════════════════════════════════════════╣
        ║  array: [1, 2, 3]                      ║
        ║  output: [2, 4, 6] ← Computed          ║
        ║  i: 3 (loop finished)                  ║
        ╚════════════════════════════════════════╝
```

#### Step 7-8: Return and Resume
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
║            (RESUMED)                    ║
╠════════════════════════════════════════╣
║  copyArrayAndMultiply2: f{}            ║
║  myArray: [1, 2, 3]                    ║
║  result: [2, 4, 6] ← Returned value    ║
╚════════════════════════════════════════╝
```

---

### Example 2: Divide by 2
```javascript
function copyArrayAndDivide2(array) {
    const output = [];
    for (let i = 0; i < array.length; i++) {
        output.push(array[i] / 2);
    }
    return output;
}

const myArray = [1, 2, 3];
const result = copyArrayAndDivide2(myArray);
// Result: [0.5, 1, 1.5]
```

**Execution follows similar steps as multiply function**

---

## Problem Identified

Both functions are **almost identical** - only the operation changes:
- `array[i] * 2` vs `array[i] / 2`

**Why write repetitive code?**

---

## Solution: Higher Order Functions (HOF)

**What if we could pass the functionality itself as a parameter?**

### How to Pass Functionality?
- Can't pass `*2` or `/2` directly
- **Wrap it in a function and pass the function**

---

## Higher Order Function Implementation

```javascript
function copyArrayAndManipulate(array, instructions) {
    const output = [];
    for (let i = 0; i < array.length; i++) {
        output.push(instructions(array[i]));
    }
    return output;
}

function multiplyBy2(input) { 
    return input * 2;
}

const result = copyArrayAndManipulate([1, 2, 3], multiplyBy2);
```

---

## Execution Context - Higher Order Function

### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  MEMORY                                ║
║                                        ║
║  copyArrayAndManipulate: f{}           ║
║  multiplyBy2: f{}                      ║
║  result: ???                           ║
║                                        ║
╚════════════════════════════════════════╝
```

### Step 2: Function Call
```
CALL STACK:
┌─────────────────────────────────────────┐
│ copyArrayAndManipulate([1,2,3], f{})    │ ← EXECUTING
├─────────────────────────────────────────┤
│ Global Context (PAUSED)                 │
└─────────────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ║  copyArrayAndManipulate                ║
        ╠════════════════════════════════════════╣
        ║  array: [1, 2, 3]                      ║
        ║  instructions: f{multiplyBy2}          ║
        ║  output: []                            ║
        ║  i: 0                                  ║
        ╚════════════════════════════════════════╝
```

### Step 3: First Loop Iteration (i=0)
```
CALL STACK:
┌─────────────────────────────────────────┐
│ multiplyBy2(1)                          │ ← EXECUTING
├─────────────────────────────────────────┤
│ copyArrayAndManipulate (PAUSED)         │
├─────────────────────────────────────────┤
│ Global Context (PAUSED)                 │
└─────────────────────────────────────────┘

                ╔════════════════════════════╗
                ║  multiplyBy2(1)            ║
                ╠════════════════════════════╣
                ║  input: 1                  ║
                ║  returns: 2                ║
                ╚════════════════════════════╝
                        ↓
        ╔════════════════════════════════════════╗
        ║  copyArrayAndManipulate                ║
        ╠════════════════════════════════════════╣
        ║  array: [1, 2, 3]                      ║
        ║  instructions: f{multiplyBy2}          ║
        ║  output: [2] ← value pushed            ║
        ║  i: 0                                  ║
        ╚════════════════════════════════════════╝
```

### Step 4: Second Loop Iteration (i=1)
```
                ╔════════════════════════════╗
                ║  multiplyBy2(2)            ║
                ╠════════════════════════════╣
                ║  input: 2                  ║
                ║  returns: 4                ║
                ╚════════════════════════════╝
                        ↓
        ╔════════════════════════════════════════╗
        ║  copyArrayAndManipulate                ║
        ╠════════════════════════════════════════╣
        ║  output: [2, 4] ← value pushed         ║
        ║  i: 1                                  ║
        ╚════════════════════════════════════════╝
```

### Step 5: Third Loop Iteration (i=2)
```
                ╔════════════════════════════╗
                ║  multiplyBy2(3)            ║
                ╠════════════════════════════╣
                ║  input: 3                  ║
                ║  returns: 6                ║
                ╚════════════════════════════╝
                        ↓
        ╔════════════════════════════════════════╗
        ║  copyArrayAndManipulate                ║
        ╠════════════════════════════════════════╣
        ║  output: [2, 4, 6] ← final             ║
        ║  i: 2                                  ║
        ╚════════════════════════════════════════╝
```

### Step 6: Return to Global
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╣
║  copyArrayAndManipulate: f{}           ║
║  multiplyBy2: f{}                      ║
║  result: [2, 4, 6] ← Returned          ║
╚════════════════════════════════════════╝
```

---

## Important Questions Answered

### Q1: Does HOF pass function definition, reference, or copy?

**Answer: REFERENCE (but safe reference)**

```
Global Memory:
  multiplyBy2: 0x001 → f{code here}
                ↓
Local Memory (copyArrayAndManipulate):
  instructions: 0x001 → (points to same function)
```

- **NOT a direct reference** that causes side effects
- **NOT a copy** (that would waste memory)
- It's a **reference to the function object** in memory
- Functions are **immutable** in this context, so it's safe

**For arrays `[1,2,3]`:**
- Arrays are passed by reference
- We create a NEW array (`output`) to avoid side effects
- Original array remains unchanged

---

### Q2: Does the `for` loop get its own execution context?

**Answer: NO**

```
╔════════════════════════════════════════╗
║  copyArrayAndManipulate                ║
╠════════════════════════════════════════╣
║  array: [1, 2, 3]                      ║
║  instructions: f{}                     ║
║  output: []                            ║
║  i: 0 ← loop variable in SAME context  ║
╚════════════════════════════════════════╝
```

- **Loop does NOT create execution context**
- **Loop DOES create its own namespace/scope**
- Variable `i` exists in the function's local memory
- Block scope with `let` keeps `i` confined to the loop

---

## Key Terminology

### Higher Order Function (HOF)
**Definition:** A function that either:
1. Takes a function as a parameter, OR
2. Returns a function

**Example:**
```javascript
copyArrayAndManipulate // ← Higher Order Function
```

### Callback Function
**Definition:** A function passed as an argument to another function

**Example:**
```javascript
multiplyBy2 // ← Callback Function
```

---

## First-Class Objects

### What are First-Class Objects?

**In JavaScript, functions are first-class objects**, meaning they can be:
1. Assigned to variables
2. Passed as arguments to other functions
3. Returned from functions
4. Stored in data structures (arrays, objects)

**Example:**
```javascript
// 1. Assign to variable
const myFunc = function() { return 5; };

// 2. Pass as argument
doSomething(myFunc);

// 3. Return from function
function getFunction() {
    return function() { return 10; };
}

// 4. Store in array
const funcs = [myFunc, getFunction];
```

### Is Everything in JavaScript an Object?

**NO, but almost everything behaves like one:**

**Primitive Types (NOT objects):**
- `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

**Objects:**
- `Object`, `Array`, `Function`, `Date`, `RegExp`, etc.

**Special Case:**
- Primitives have "wrapper objects" (`String`, `Number`, `Boolean`)
- When you call methods on primitives, JavaScript temporarily wraps them

```javascript
"hello".toUpperCase() // String is temporarily wrapped as object
```

---

## Arrow Functions

### Evolution of Function Syntax

```javascript
// 1. Traditional Function
function multiplyBy2(input) { 
    return input * 2;
}

// 2. Arrow Function (full syntax)
const multiplyBy2 = (input) => { 
    return input * 2;
}

// 3. Arrow Function (implicit return)
const multiplyBy2 = (input) => input * 2;

// 4. Arrow Function (single parameter, no parentheses)
const multiplyBy2 = input => input * 2;
```

### Arrow Function Benefits
- Shorter, cleaner syntax
- Implicit return for single expressions
- More readable for simple functions
- Great for callbacks

---

## Arrow Functions with HOF

```javascript
function copyArrayAndManipulate(array, instructions) {
    const output = [];
    for (let i = 0; i < array.length; i++) {
        output.push(instructions(array[i]));
    }
    return output;
}

// Using arrow function directly as callback
const result = copyArrayAndManipulate([1, 2, 3], input => input * 2);
```

---

## Execution with Arrow Function

### Step 1: Global Setup
```
╔════════════════════════════════════════╗
║     GLOBAL EXECUTION CONTEXT           ║
╠════════════════════════════════════════╗
║  copyArrayAndManipulate: f{}           ║
║  result: ???                           ║
║                                        ║
║  (No separate multiplyBy2 stored!)     ║
╚════════════════════════════════════════╝
```

### Step 2: Function Call with Anonymous Arrow Function
```
CALL STACK:
┌─────────────────────────────────────────┐
│ copyArrayAndManipulate([1,2,3], f{})    │
├─────────────────────────────────────────┤
│ Global Context (PAUSED)                 │
└─────────────────────────────────────────┘

        ╔════════════════════════════════════════╗
        ║  LOCAL EXECUTION CONTEXT               ║
        ╠════════════════════════════════════════╣
        ║  array: [1, 2, 3]                      ║
        ║  instructions: f{input => input * 2}   ║
        ║        ↑                               ║
        ║  Anonymous arrow function              ║
        ║  output: []                            ║
        ╚════════════════════════════════════════╝
```

### Step 3: Arrow Function Called (i=0)
```
                ╔════════════════════════════╗
                ║  (input => input * 2)(1)   ║
                ╠════════════════════════════╣
                ║  input: 1                  ║
                ║  returns: 2 (implicit)     ║
                ╚════════════════════════════╝
```

### Key Difference:
- Arrow function is **created on-the-fly**
- **No name** stored in global memory
- Called **anonymous function**
- Executes same way as named function

---

## Anonymous Functions

### What is an Anonymous Function?

**Definition:** A function without a name

```javascript
// Named function
function multiplyBy2(input) { return input * 2; }

// Anonymous function
(input) => input * 2
```

### Why Use Anonymous Functions?

- **Less Code:** No need to create separate named function
- **One-time Use:** Perfect for callbacks used only once
- **Cleaner:** Reduces global namespace pollution
- **Readable:** Logic stays close to where it's used

### When to Use:
- Callbacks for HOF (map, filter, reduce)
- Event handlers
- Short, simple operations
- When function won't be reused

---

## Comparison Table

| Feature | Named Function | Arrow Function | Anonymous Arrow |
|---------|---------------|----------------|-----------------|
| **Syntax** | `function name() {}` | `const name = () => {}` | `() => {}` |
| **Stored in Memory** | Yes | Yes (if assigned) | No |
| **Reusable** | Yes | Yes (if assigned) | No |
| **Use Case** | Reusable logic | Modern syntax | One-time callbacks |
| **Code Length** | Longest | Medium | Shortest |

---

## Complete Example Comparison

### Repetitive Way
```javascript
function copyArrayMultiply2(arr) {
    const output = [];
    for (let i = 0; i < arr.length; i++) {
        output.push(arr[i] * 2);
    }
    return output;
}

function copyArrayDivide2(arr) {
    const output = [];
    for (let i = 0; i < arr.length; i++) {
        output.push(arr[i] / 2);
    }
    return output;
}

const result1 = copyArrayMultiply2([1,2,3]);
const result2 = copyArrayDivide2([1,2,3]);
```

### HOF Way (Named Callback)
```javascript
function copyArrayAndManipulate(arr, instructions) {
    const output = [];
    for (let i = 0; i < arr.length; i++) {
        output.push(instructions(arr[i]));
    }
    return output;
}

function multiplyBy2(input) { return input * 2; }
function divideBy2(input) { return input / 2; }

const result1 = copyArrayAndManipulate([1,2,3], multiplyBy2);
const result2 = copyArrayAndManipulate([1,2,3], divideBy2);
```

### HOF Way (Anonymous Arrow)
```javascript
function copyArrayAndManipulate(arr, instructions) {
    const output = [];
    for (let i = 0; i < arr.length; i++) {
        output.push(instructions(arr[i]));
    }
    return output;
}

const result1 = copyArrayAndManipulate([1,2,3], input => input * 2);
const result2 = copyArrayAndManipulate([1,2,3], input => input / 2);
```

---

## Summary

### Key Concepts:
1. **DRY Principle:** Don't repeat code
2. **HOF:** Functions that take/return functions
3. **Callback:** Function passed as argument
4. **First-Class Objects:** Functions can be treated like any value
5. **Arrow Functions:** Shorter syntax for functions
6. **Anonymous Functions:** Unnamed functions for one-time use

### Execution Flow:
1. Functions are stored as objects in memory
2. Passing functions = passing references (safe)
3. Loops don't create execution contexts
4. Each function call creates local context
5. Arrow functions work identically to regular functions

### Benefits:
- Write less code
- More reusable
- Easier to maintain
- More readable (with practice)
- Flexible and powerful