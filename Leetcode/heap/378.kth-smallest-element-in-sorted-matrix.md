# 378\. Kth Smallest Element in a Sorted Matrix (LeetCode)

> Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, return the k-th smallest element in the matrix. This must be solved with a memory complexity better than $O(n^2)$.

-----

## üìù Problem Description

Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than $O(n^2)$.

**Example 1:**

```
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
```

**Example 2:**

```
Input: matrix = [[-5]], k = 1
Output: -5
```

-----

## üí° Approach: Max-Heap of Size K

This problem can be solved efficiently by leveraging a heap, specifically a max-heap of a fixed size `k`. The constraints and the requirement for a memory complexity better than $O(N^2)$ strongly suggest an approach that avoids storing all $N^2$ elements in memory.

The approach is to maintain a max-heap that stores the `k` smallest elements encountered so far. A max-heap is used because its largest element is always at the top.

The logic is as follows:

  * We need to find the *kth smallest* element.
  * We iterate through all $N^2$ elements of the matrix.
  * For each element, push it into the max-heap.
  * If the size of the max-heap exceeds `k`, pop the top element. Since it is a max-heap, the element at the top is the largest among the elements currently in the heap.
  * By doing this, we ensure the heap always contains the `k` smallest elements we have seen so far. The largest of these `k` smallest elements is the one that is at the top of the max-heap.

After iterating through the entire matrix, the element at the top of the max-heap will be the k-th smallest element overall.

-----

## üö∂ Algorithm Steps

1.  Create a max-heap (`std::priority_queue`).
2.  Iterate through each element of the `n x n` matrix.
3.  Push the current matrix element onto the max-heap.
4.  If the size of the max-heap becomes greater than `k`, pop the top element from the heap.
5.  After the nested loops complete, return the top element of the max-heap.

-----

## üíª Example Walkthrough

Let's trace the algorithm with `matrix = [[1,5,9],[10,11,13],[12,13,15]]` and `k = 8`. The matrix has 9 elements.

1.  Create an empty max-heap `maxH`. `k = 8`.
2.  Iterate through the matrix elements one by one, pushing to `maxH`.
3.  **Elements `1, 5, 9, 10, 11, 13, 12, 13` are pushed**: The size of `maxH` grows to 8. It contains `[1, 5, 9, 10, 11, 13, 12, 13]` (internal order will be a heap, not sorted). The largest element is `13` at the top.
4.  **`num = 15`**: `maxH.push(15)`. `maxH` size is 9. `[1,5,9,10,11,12,13,13,15]`.
      * Since `maxH.size() > k` (9 \> 8) is true, `maxH.pop()`.
      * The largest element (`15`) is popped.
      * `maxH` now contains the 8 smallest elements from the list, with `13` at the top.
5.  The loops finish.
6.  Return `maxH.top()`, which is **13**.

The 8th smallest element is indeed 13.

-----

## üìè Constraints

  * `n == matrix.length == matrix[i].length`
  * `1 <= n <= 300`
  * `-10^9 <= matrix[i][j] <= 10^9`
  * All the rows and columns of the matrix are guaranteed to be sorted in non-decreasing order.
  * `1 <= k <= n^2`

-----

## ‚è±Ô∏è Complexity Analysis

  * **Time Complexity**: $O(N^2 \log K)$, where `N` is the dimension of the matrix. We iterate through all $N^2$ elements of the matrix, and for each element, we perform a heap `push` or `pop` operation. These operations on a heap of size `K` take $O(\log K)$ time.
  * **Space Complexity**: $O(K)$, as the max-heap stores at most `K` elements. This satisfies the problem's constraint of a memory complexity better than $O(N^2)$.

-----

## üîë Key Idea

The core idea is to leverage a max-heap to efficiently track the `k` smallest elements seen so far. A max-heap is chosen for this task because its largest element is at the top. By keeping the heap size capped at `k`, any new element that is smaller than the largest of our `k` candidates will be retained, while the largest candidate is discarded. The final element at the top of the heap is the k-th smallest element overall. This avoids the need to flatten and sort the entire matrix, leading to an optimal solution for cases where `K` is significantly smaller than $N^2$.

-----

## üíª Class Implementation

```cpp
#include <vector>
#include <queue>

class Solution {
public:
    int kthSmallest(std::vector<std::vector<int>>& matrix, int k) {
        // Create a max-heap (std::priority_queue default is max-heap)
        std::priority_queue<int> maxH;

        // Iterate through all elements of the n x n matrix
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = 0; j < matrix[i].size(); ++j) {
                maxH.push(matrix[i][j]);

                // If the heap size exceeds k, pop the largest element
                if (maxH.size() > k) {
                    maxH.pop();
                }
            }
        }
        
        // The top of the max-heap is the kth smallest element
        return maxH.top();
    }
};
```

-----

**Last Updated:** August 5, 2025

**Documentation Source:** [LeetCode 378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)