# 33\. Search in Rotated Sorted Array (LeetCode)

> Search for a `target` value in a rotated sorted array with unique elements, in $O(\\log n)$ runtime complexity.

-----

## 📝 Problem Description

There is an integer array `nums` sorted in ascending order (with distinct values).

Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`.

You must write an algorithm with $O(\\log n)$ runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Example 3:**

```
Input: nums = [1], target = 0
Output: -1
```

-----

## 💡 Approach: Find Pivot then Binary Search

The core idea for solving this problem in $O(\log n)$ time leverages the properties of a rotated sorted array and applies binary search twice:

1.  **Find the Rotation Point (Minimum Element's Index)**: A rotated sorted array is essentially two sorted arrays merged, where the minimum element acts as the "pivot" or the start of the second sorted segment. We can find this minimum element's index using a modified binary search similar to LeetCode problem 153.

      * By comparing `nums[mid]` with `nums[end]`, we can determine which segment `mid` falls into and narrow down the search for the minimum. If `nums[mid] > nums[end]`, the pivot (minimum) is to the right of `mid`. Otherwise, the pivot is at or to the left of `mid`.

2.  **Determine Target's Segment**: Once the pivot index (`minIndex`) is found, the array is effectively divided into two sorted subarrays:

      * `[nums[0], ..., nums[minIndex - 1]]` (the first sorted part)
      * `[nums[minIndex], ..., nums[nums.size() - 1]]` (the second sorted part, starting with the minimum)
        Now, we can check which of these two sorted segments the `target` could possibly belong to by comparing `target` with the values at the `start` (index 0) and `end` (last index) of the entire array, relative to `nums[minIndex]`.

3.  **Perform Standard Binary Search**: Finally, apply a standard binary search (the basic $O(\\log n)$ algorithm) on the identified sorted segment to find the `target`.

-----

## 🚶 Algorithm Steps

1.  **Handle Empty Array**: If `nums` is empty, return -1 immediately.
2.  **Step 1: Find the Minimum Element's Index (Pivot)**
      * Initialize `start = 0`, `end = nums.size() - 1`.
      * Use a binary search loop (`while (start < end)`):
          * Calculate `mid = start + (end - start) / 2`.
          * If `nums[mid] > nums[end]`: The minimum is in the right half. Set `start = mid + 1`.
          * Else (`nums[mid] <= nums[end]`): The minimum is in the left half (including `mid`). Set `end = mid`.
      * After this loop, `start` (or `end`) will hold the `minIndex` of the smallest element in the array.
3.  **Step 2: Determine Which Segment to Search**
      * Initialize `actual_search_start` and `actual_search_end` for the final binary search.
      * If `target >= nums[minIndex]` AND `target <= nums[nums.size() - 1]` (i.e., `target` is in the range of values in the right sorted segment):
          * Set `actual_search_start = minIndex`.
          * Set `actual_search_end = nums.size() - 1`.
      * Else (the `target` must be in the range of values in the left sorted segment):
          * Set `actual_search_start = 0`.
          * Set `actual_search_end = minIndex - 1`.
4.  **Step 3: Perform Standard Binary Search on the Selected Segment**
      * Call a helper binary search function (`binary_search` in the provided code) with `nums`, `target`, `actual_search_start`, and `actual_search_end`.
      * This helper function will return the index of `target` if found, or -1 otherwise.

-----

## 💻 Example Walkthrough

Let's trace the algorithm with `nums = [4,5,6,7,0,1,2]`, `target = 0`

1.  **Initial:** `nums` is not empty. `start = 0`, `end = 6`.

2.  **Step 1: Find `minIndex`**

      * **Iteration 1:**
          * `start = 0`, `end = 6`. `mid = 0 + (6-0)/2 = 3`.
          * `nums[mid]` (`nums[3]`) = `7`. `nums[end]` (`nums[6]`) = `2`.
          * `nums[mid] > nums[end]` (7 \> 2) is `true`.
          * `start = mid + 1 = 4`.
          * Current state: `start = 4`, `end = 6`.
      * **Iteration 2:**
          * `start = 4`, `end = 6`. `mid = 4 + (6-4)/2 = 5`.
          * `nums[mid]` (`nums[5]`) = `1`. `nums[end]` (`nums[6]`) = `2`.
          * `nums[mid] > nums[end]` (1 \> 2) is `false`.
          * `end = mid = 5`.
          * Current state: `start = 4`, `end = 5`.
      * **Iteration 3:**
          * `start = 4`, `end = 5`. `mid = 4 + (5-4)/2 = 4`.
          * `nums[mid]` (`nums[4]`) = `0`. `nums[end]` (`nums[5]`) = `1`.
          * `nums[mid] > nums[end]` (0 \> 1) is `false`.
          * `end = mid = 4`.
          * Current state: `start = 4`, `end = 4`.
      * Loop terminates (`start == end`). `minIndex = 4`. (`nums[4]` is `0`, which is indeed the minimum).

3.  **Step 2: Determine Search Segment**

      * `target = 0`.
      * `nums[minIndex]` (`nums[4]`) = `0`.
      * `nums[nums.size() - 1]` (`nums[6]`) = `2`.
      * Is `target >= nums[minIndex]` (`0 >= 0`) AND `target <= nums[nums.size() - 1]` (`0 <= 2`)? Yes, both are true.
      * So, search in the right segment: `actual_search_start = minIndex = 4`, `actual_search_end = nums.size() - 1 = 6`.

4.  **Step 3: Perform Binary Search** on `nums = [4,5,6,7,0,1,2]` for `target = 0` in range `[4, 6]` (`[0,1,2]`).

      * `start = 4`, `end = 6`.
      * `mid = 4 + (6-4)/2 = 5`. `nums[5] = 1`. `1 > 0`, so `end = mid - 1 = 4`.
      * `start = 4`, `end = 4`.
      * `mid = 4 + (4-4)/2 = 4`. `nums[4] = 0`. `0 == target`, return `mid`.
      * Returns `4`.

The algorithm correctly returned `4`.

-----

## 📏 Constraints

  * `n == nums.length`
  * `1 <= n <= 5000`
  * `-5000 <= nums[i] <= 5000`
  * All the integers of `nums` are unique.
  * `nums` is sorted and rotated between 1 and `n` times.

-----

## ⏱️ Complexity Analysis

  * **Time Complexity**: $O(\\log n)$.
      * Finding the minimum element's index (pivot) takes $O(\\log n)$ time using binary search.
      * Determining the correct segment to search takes $O(1)$ time.
      * Performing the final binary search on one of the two segments takes another $O(\\log n)$ time.
      * The total time complexity is $O(\\log n) + O(1) + O(\\log n) = O(\\log n)$.
  * **Space Complexity**: $O(1)$, as the algorithm uses a constant amount of extra space for pointers and variables.

-----

## 🔑 Key Idea

The core idea is to decompose the problem into two standard binary search operations. First, find the unique "pivot" (minimum element) that splits the rotated array into two truly sorted segments. Once the pivot is located, determine which of these two segments the target could possibly exist in based on its value relative to the segment boundaries. Finally, perform a standard binary search on that specific, now-sorted, segment. This two-stage binary search maintains the required logarithmic time complexity.

-----

## 💻 Class Implementation

```cpp
#include <vector> // Required for std::vector
#include <algorithm> // Not strictly necessary for this implementation but common for algorithms

class Solution {
public:
    // Helper function for standard binary search on a given range
    int binary_search(std::vector<int>& nums, int target, int startIndex, int endIndex){
        int start = startIndex;
        int end = endIndex;

        while(start <= end){
            int mid = start + (end-start)/2; // Safe mid calculation

            if(nums[mid] == target) {
                return mid; // Target found
            } else if (nums[mid] > target) {
                end = mid-1; // Target is in the left half
            } else { // nums[mid] < target
                start = mid + 1; // Target is in the right half
            }
        }
        return -1; // Target not found in this segment
    }

    int search(std::vector<int>& nums, int target) {
        if(nums.empty()) {
            return -1; // Handle empty array case
        }
        
        // Step 1: Find the index of the minimum element (pivot)
        int start = 0;
        int end = nums.size() - 1;

        while(start < end){
            int mid = start + (end-start) / 2;

            if(nums[mid] > nums[end]) {
                // If mid element is greater than end element,
                // the minimum is in the right subarray (mid+1 to end).
                start = mid + 1;
            } else {
                // If mid element is less than or equal to end element,
                // the minimum is in the left subarray (start to mid).
                // mid could be the minimum, so we keep it in the range.
                end = mid;
            }
        }
        // At this point, 'start' (which equals 'end') is the index of the minimum element.
        int minIndex = start; 
        
        // Step 2: Determine which half the target might be in
        // (This implicitly re-initializes start/end for the main array)
        int search_start_idx;
        int search_end_idx;

        // If target is within the range of the second sorted part (from minIndex to end)
        if (target >= nums[minIndex] && target <= nums[nums.size() - 1]) {
            search_start_idx = minIndex;
            search_end_idx = nums.size() - 1;
        } 
        // Otherwise, target must be in the first sorted part (from 0 to minIndex - 1)
        else {
            search_start_idx = 0;
            search_end_idx = minIndex - 1;
        }
        
        // Step 3: Perform standard binary search on the determined segment
        return binary_search(nums, target, search_start_idx, search_end_idx);
    }
};
```

-----

**Last Updated:** August 2, 2025
**Documentation Source:** [LeetCode 33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)